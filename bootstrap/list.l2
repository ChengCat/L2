(function @car (l) (@ car $l))

(function @cdr (l) (@ cdr $l))

(function @cddr (l) [@cdr [@cdr $l]])

(function @cdddr (l) [@cdr [@cddr $l]])

(function @cddddr (l) [@cdr [@cdddr $l]])

(function @cdddddr (l) [@cdr [@cddddr $l]])

(function @cddddddr (l) [@cdr [@cdddddr $l]])

(function @cadr (l) [@car [@cdr $l]])

(function @caddr (l) [@car [@cddr $l]])

(function @cadddr (l) [@car [@cdddr $l]])

(function @caddddr (l) [@car [@cddddr $l]])

(function @cadddddr (l) [@car [@cdddddr $l]])

(storage nil nil (null))

(function nil? (l) [= [@cdr $l] (null)])

(function append (data l r handler err) (with return (begin
	(while (not [nil? $$l]) [set l (& cdr $$l)])
	[set $l [buffer-alloc (list-struct) $r $handler $err]]
	(setf car $$l $data)
	(setf cdr $$l nil)
	{return (& car $$l)})))

(function cons (data rest r handler err) (with return
	(let (l [buffer-alloc (list-struct) $r $handler $err]) (begin
		(setf car $l $data)
		(setf cdr $l $rest)
		{return $l}))))

(function append-list (fst-ref snd) (begin
	(while (not [nil? $$fst-ref])
		[set fst-ref (& cdr $$fst-ref)])
	[set $fst-ref $snd]))

(function prepend (data l-ref r handler err)
	(let (ret [buffer-alloc (list-struct) $r $handler $err]) (begin
		(setf car $ret $data)
		(setf cdr $ret $$l-ref)
		[set $l-ref $ret])))

(function length (l) (with return
	{(continuation loop (l size)
		(if [nil? $l]
			{return $size}
			{loop [@cdr $l] [+ #1 $size]})) $l #0}))

(function find (pred l ctx) (with return (begin
	(until (s $l) [nil? $$s] (& cdr $$s)
		(if [$pred [@car $$s] $ctx] {return $s} (begin)))
	{return (null)})))

(function not-subset (pred a b) (with return (begin
	(foreach (d $a) (if [find $pred b $d] (begin) {return $d}))
	{return (null)})))

(function filter (pred l r handler err) (with return
	(let (res nil) (begin
		(foreach (e $l) (if [$pred $e] [prepend $e res $r $handler $err] (begin)))
		{return [reverse $res $r $handler $err]}))))

(function reverse (l r handler err) (with return
	(let (ret nil) (begin
		(foreach (data $l) [prepend $data ret $r $handler $err])
		{return $ret}))))

(function map (l ctx mapper r handler err)
	(with return
		{(continuation aux (in out)
			(if [nil? $in]
				{return [reverse $out $r $handler $err]}
				{aux [@cdr $in] [cons [$mapper [@car $in] $ctx] $out $r $handler $err]})) $l nil}))
