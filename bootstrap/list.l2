(function meta:zip (a b r) (with return
	{(continuation aux (output a b)
		(if (not [emt? $a])
			{aux [lst [llst [@fst $a] [@fst $b] emt $r] $output $r] [@rst $a] [@rst $b]}
			{return [meta:reverse $output $r]})) emt $a $b}))

(function foreach (s r p) (use-memo $p
	(let (bindings [meta:reverse [@rst [meta:reverse $s $r]] $r]) (body [@fst [meta:reverse $s $r]])
			(labels (with return {(continuation aux (index-refs ref input-pairs)
				(if (not [emt? $input-pairs])
					{aux [lst $ref $index-refs $r]
						[meta:reverse [lst -1- [meta:reverse $ref $r]$r]$r]
						[@rst $input-pairs]}
					{return [meta:reverse $index-refs $r]})) emt (` foreach:v $r) [@rst [meta:reverse $s $r]]}))
		[lst (` let $r) [meta:reverse [lst
			(`(while (not [emt? $foreach:v]) (,[llst (` begin $r)
				[lst (` let $r) [meta:reverse [lst $body [meta:map [meta:zip [meta:map $bindings (null) @fst $r] $labels $r]
						$r (function make-binding (a r) (`((,[@fst $a]) [@car ($(,[@frst $a]))])$r))$r]$r]$r]$r]
				[meta:map $labels $r (function make-update (a r) (`[set ,$a [@cdr $,$a]]$r))$r]$r]))$r)
			[meta:zip $labels [meta:map $bindings (null) @frst $r]$r]$r]$r]$r])))

(function foreach* (s r p) (use-memo $p
	(let (bindings [meta:reverse [@rst [meta:reverse $s $r]]$r]) (body [@fst [meta:reverse $s $r]])
		[lst (` let $r) [meta:reverse [lst
			(`(while (not [emt? ($($(,[@ffst $bindings])))]) (,[llst (` begin $r) $body
				[meta:map $bindings $r (function make-update (a r)
					(`[set (,[@fst $a]) [cdr ($($(,[@fst $a])))]]$r))$r]$r]))$r)
			$bindings $r]$r]$r])))

(function list (l r p) (use-memo $p
	(with return (let (l [meta:reverse $l $r])
		{(continuation loop (out in)
			(if [emt? $in]
				{return $out}
				{loop [lllllst (` invoke $r) (` cons $r) [@fst $in] $out [@fst $l] emt $r] [@rst $in]})) (` nil $r) [@rst $l]}))))

(function list-struct (l r p) (use-memo $p (`[* &2(unit)]$r)))

(function car (l) $l)

(function cdr (l) [+ $l (unit)])

(function @car (l) ($[car $l]))

(function @cdr (l) ($[cdr $l]))

(function @cddr (l) [@cdr [@cdr $l]])

(function @cdddr (l) [@cdr [@cddr $l]])

(function @cddddr (l) [@cdr [@cdddr $l]])

(function @cdddddr (l) [@cdr [@cddddr $l]])

(function @cddddddr (l) [@cdr [@cdddddr $l]])

(function @cadr (l) [@car [@cdr $l]])

(function @caddr (l) [@car [@cddr $l]])

(function @cadddr (l) [@car [@cdddr $l]])

(function @caddddr (l) [@car [@cddddr $l]])

(function @cadddddr (l) [@car [@cdddddr $l]])

(function car! (l v) [set [car $l] $v])

(function cdr! (l v) [set [cdr $l] $v])

(storage nil nil (null))

(function nil? (l) [= [@cdr $l] (null)])

(function append (data l r) (with return (begin
	(while (not [nil? $$l]) [set l [cdr $$l]])
	[set $l [region-alloc $r (list-struct)]]
	[car! $$l $data]
	[cdr! $$l nil]
	{return [car $$l]})))

(function cons (data rest r) (with return
	(let (l [region-alloc $r (list-struct)]) (begin
		[car! $l $data]
		[cdr! $l $rest]
		{return $l}))))

(function append-list (fst-ref snd) (begin
	(while (not [nil? $$fst-ref])
		[set fst-ref [cdr $$fst-ref]])
	[set $fst-ref $snd]))

(function prepend (data l-ref r)
	(let (ret [region-alloc $r (list-struct)]) (begin
		[car! $ret $data]
		[cdr! $ret $$l-ref]
		[set $l-ref $ret])))

(function length (l) (with return
	{(continuation loop (l size)
		(if (not [nil? $l])
			{loop [@cdr $l] [+ &1 $size]}
			{return $size})) $l &0}))

(function find (pred l ctx) (with return (begin
	(foreach* (s $l)
		(if [$pred [@fst $$s] $ctx] {return $s} (begin)))
	{return (null)})))

(function filter (pred l r) (with return
	(let (res nil) (begin
		(foreach (e $l) (if [$pred $e] [prepend $e res $r] (begin)))
		{return [reverse $res $r]}))))

(function reverse (l r) (with return
	(let (ret nil) (begin
		(foreach (data $l) [prepend $data ret $r])
		{return $ret}))))

(let (r [create-region &0])
	(let (l nil) (begin
		[append (" Hello) l $r]
		[append (" And) l $r]
		[append (" Then) l $r]
		[append (" Bye) l $r]
		[write-uint (stdout) [length $l]]
		(foreach (ele (list (" This) (" Right) (" Here) (" Is) $r)) (okay $l) (begin
			[write-str (stdout) $ele]
			[write-str (stdout) (" :)]
			[write-str (stdout) $okay]
			[write-char (stdout) (lf)]))
		[write-char (stdout) (lf)])))
