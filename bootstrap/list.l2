(function meta:zip (a b r) (with return
	{(continuation aux (output a b)
		(if [not [emt? $a]]
			{aux [lst [llst [fst $a] [fst $b] [emt $r] $r] $output $r] [rst $a] [rst $b]}
			{return [meta:reverse $output $r]})) [emt $r] $a $b}))

(function foreach (s r)
	(let (bindings [meta:reverse [rst [meta:reverse $s $r]] $r]) (body [fst [meta:reverse $s $r]])
			(labels (with return {(continuation aux (index-refs ref input-pairs)
				(if [not [emt? $input-pairs]]
					{aux [lst $ref $index-refs $r]
						[meta:reverse [lst [-1- $r][meta:reverse $ref $r]$r]$r]
						[rst $input-pairs]}
					{return [meta:reverse $index-refs $r]})) [emt $r] (` foreach:v $r) [rst [meta:reverse $s $r]]}))
		[lst (` let $r) [meta:reverse [lst
			(`(while [not [emt? $foreach:v]] (,[llst (` begin $r)
				[lst (` let $r) [meta:reverse [lst $body [meta:map [meta:zip [meta:map $bindings (null) fst $r] $labels $r]
						$r (function make-binding (a r) (`((,[fst $a]) ($[car ($(,[frst $a]))]))$r))$r]$r]$r]$r]
				[meta:map $labels $r (function make-update (a r) (`[set ,$a ($[cdr $,$a])]$r))$r]$r]))$r)
			[meta:zip $labels [meta:map $bindings (null) frst $r]$r]$r]$r]$r]))

(function foreach* (s r)
	(let (bindings [meta:reverse [rst [meta:reverse $s $r]]$r]) (body [fst [meta:reverse $s $r]])
		[lst (` let $r) [meta:reverse [lst
			(`(while [not [emt? ($($(,[ffst $bindings])))]] (,[llst (` begin $r) $body
				[meta:map $bindings $r (function make-update (a r)
					(`[set (,[fst $a]) [cdr ($($(,[fst $a])))]]$r))$r]$r]))$r)
			$bindings $r]$r]$r]))

(function list-struct (l r) (`[* &2(unit)]$r))

(function car (l) $l)

(function cdr (l) [+ $l (unit)])

(function cddr (l) [cdr ($[cdr $l])])

(function cdddr (l) [cdr ($[cddr $l])])

(function cddddr (l) [cdr ($[cdddr $l])])

(function cdddddr (l) [cdr ($[cddddr $l])])

(function cddddddr (l) [cdr ($[cdddddr $l])])

(function cadr (l) [car ($[cdr $l])])

(function caddr (l) [car ($[cddr $l])])

(function cadddr (l) [car ($[cdddr $l])])

(function caddddr (l) [car ($[cddddr $l])])

(function cadddddr (l) [car ($[cdddddr $l])])

(function nil (r) (with return
	(let (l [region-alloc $r (list-struct)]) (begin
		[set [car $l] $l]
		[set [cdr $l] (null)]
		{return $l}))))

(function nil? (l)
	(if [= ($[cdr $l]) (null)] (true) (false)))

(function append (data l r) (with return (begin
	(while [not [nil? $$l]] [set l [cdr $$l]])
	[set $l [region-alloc $r (list-struct)]]
	[set [car $$l] $data]
	[set [cdr $$l] [nil $r]]
	{return [car $$l]})))

(function cons (data rest r) (with return
	(let (l [region-alloc $r (list-struct)]) (begin
		[set [car $l] $data]
		[set [cdr $l] $rest]
		{return $l}))))

(function append-list (fst-ref snd) (begin
	(while [not nil? $$fst-ref]
		[set fst-ref [cdr $$fst-ref]])
	[set $fst-ref $snd]))

(function prepend (data l-ref r)
	(let (ret [region-alloc $r (list-struct)]) (begin
		[set [car $ret] $data]
		[set [cdr $ret] $$l-ref]
		[set $l-ref $ret])))

(function length (l) (with return
	(let (size &0) (begin
		(while [not [nil? $l]] (begin
			[set l ($[cdr $l])]
			[set size [+ &1 $size]]))
		{return $size}))))

(function find (pred l ctx) (with return (begin
	(foreach* (s $l)
		(if [$pred [fst $$s] $ctx] {return $s} (begin)))
	{return (null)})))

(function reverse (l r) (with return
	(let (ret [nil $r]) (begin
		(foreach (data $l) [prepend $data ret])
		{return $ret}))))

(let (r [create-region &0])
	(let (l [nil $r]) (begin
		[append (" Hello) l $r]
		[append (" And) l $r]
		[append (" Then) l $r]
		[append (" Bye) l $r]
		[write-uint (stdout) [length $l]]
		(foreach (ele [reverse $l $r]) (begin
			[write-str (stdout) $ele]
			[write-str (stdout) ("(lf))]))
		[write-str (stdout) (" (lf))])))
