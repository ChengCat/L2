(++ The following functions are abbreviations of sequences of list operations
	that are frequently useful when working with s-expressions.)

(function frst (l) [fst [rst [get l]]])

(function ffrst (l) [fst [frst [get l]]])

(function frfrst (l) [fst [rst [frst [get l]]]])

(function rrst (l) [rst [rst [get l]]])

(function rrrst (l) [rst [rrst [get l]]])

(function rfst (l) [rst [fst [get l]]])

(function frfst (l) [fst [rfst [get l]]])

(function frrfst (l) [fst [rst [rfst [get l]]]])

(function frrst (l) [fst [rst [rst [get l]]]])

(function frrrst (l) [fst [rst [rst [rst [get l]]]]])

(function ffst (l) [fst [fst [get l]]])

(function llst (a b c r) [lst [get a] [lst [get b] [get c] [get r]] [get r]])

(function lllst (a b c d r) [lst [get a] [llst [get b] [get c] [get d] [get r]] [get r]])

(function llllst (a b c d e r) [lst [get a] [lllst [get b] [get c] [get d] [get e] [get r]] [get r]])

(function lllllst (a b c d e f r) [lst [get a] [llllst [get b] [get c] [get d] [get e] [get f] [get r]] [get r]])

(function llllllst (a b c d e f g r) [lst [get a] [lllllst [get b] [get c] [get d] [get e] [get f] [get g] [get r]] [get r]])

(function lllllllst (a b c d e f g h r) [lst [get a] [llllllst [get b] [get c] [get d] [get e] [get f] [get g] [get h] [get r]] [get r]])

(++ The following function provides an abbreviation for getting a value from a
	memory address. It implements the transformation $a -> [get a].)

(function $ (var r p)
	(if [emt? [get p]] [llst
			[llllllst -i- -n- -v- -o- -k- -e- emt [get r]]
			[lllst -g- -e- -t- emt [get r]]
			[get var][get r]]
		[get p]))

(++ The following function provides a method for commenting L2 code. It
	implements the transformation (** expr1 ... exprN) -> exprN.)

(function ** (l r p)
	(if [emt? $p]
		(with return
			{(continuation find (first last)
				(if [emt? $last]
					{return $first}
					{find [fst $last] [rst $last]})) [fst $l] [rst $l]})
		$p))

(++ The following function generates the L2 code to generate an s-expression
	corresponding to the supplied s-expression. Known as backquote in other
	languages.)

(function ` (l r p)
	(if [emt? $p]
			[(function aux (s t r)
				(if [emt? $s] [lllst -e- -m- -t- emt $r]
		
				(if (if [emt? $s] &0 (if [symbol? $s] &0 (if [emt? [fst $s]]
					&0 (if [char= [ffst $s] -,-] [emt? [rfst $s]] &0))))
							[frst $s]
		
				[lllllst [llllllst -i- -n- -v- -o- -k- -e- emt $r]
					[lllst -l- -s- -t- emt $r]
						(if [symbol? $s]
								[lllst --- [fst $s] --- emt $r]
								[aux [fst $s] $t $r])
							[aux [rst $s] $t $r] $t emt $r]))) [fst $l] [frst $l] $r]
		$p))

(function use-memo (l r p)
	(if [emt? $p]
		(`(if [emt? (,[fst $l])] (,[frst $l]) (,[fst $l]))$r)
		$p))

(++ The following function provides another method for commenting L2 code. It
	implements the transformation (++ expr1 ...) -> (begin). It is being used
	for this comment to work.)

(function ++ (l r p) (use-memo $p (`(begin)$r)))

(storage hey (" Hello))

[write-str (stdout) [get hey]]

(** Now things are working: (let (d &5)
	(iter (i &5) [= $i &23] [+ $i &1] (begin
		[write-str (stdout) (" Hello(lf))]
		[write-uint (stdout) [* $d $i]]))))
