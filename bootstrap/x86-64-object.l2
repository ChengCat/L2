(function object (l r) (`[* &6(unit)]$r))

(function ehdr@ (l r) (`[get[+(,[fst $l])[* &0(unit)]]]$r))
(function shdrs@ (l r) (`[get[+(,[fst $l])[* &1(unit)]]]$r))
(function syms@ (l r) (`[get[+(,[fst $l])[* &2(unit)]]]$r))
(function relas@ (l r) (`[get[+(,[fst $l])[* &3(unit)]]]$r))
(function addends@ (l r) (`[get[+(,[fst $l])[* &4(unit)]]]$r))
(function segs@ (l r) (`[get[+(,[fst $l])[* &5(unit)]]]$r))

(function ehdr< (l r) (`[set[+(,[fst $l])[* &0(unit)]](,[frst $l])]$r))
(function shdrs< (l r) (`[set[+(,[fst $l])[* &1(unit)]](,[frst $l])]$r))
(function syms< (l r) (`[set[+(,[fst $l])[* &2(unit)]](,[frst $l])]$r))
(function relas< (l r) (`[set[+(,[fst $l])[* &3(unit)]](,[frst $l])]$r))
(function addends< (l r) (`[set[+(,[fst $l])[* &4(unit)]](,[frst $l])]$r))
(function segs< (l r) (`[set[+(,[fst $l])[* &5(unit)]](,[frst $l])]$r))


						

(function read-object (objsrc objsrc-sz reg handler) (with return
	(let (obj [region-alloc $reg (object)]) (begin
		(ehdr< $obj [region-alloc $reg (elf64-ehdr)])
		[memcpy (ehdr@ $obj) $objsrc (elf64-ehdr)]
		(shdrs< $obj [region-alloc $reg [* (e-shnum@ (ehdr@ $obj)) (elf64-shdr)]])
		(syms< $obj [region-alloc $reg [* (e-shnum@ (ehdr@ $obj)) (unit)]])
		(relas< $obj [region-alloc $reg [* (e-shnum@ (ehdr@ $obj)) (unit)]])
		(addends< $obj [region-alloc $reg [* (e-shnum@ (ehdr@ $obj)) (unit)]])
		(segs< $obj [region-alloc $reg [* (e-shnum@ (ehdr@ $obj)) (unit)]])
		
		(for (sec-idx &0 (e-shnum@(ehdr@ $obj)))
			(let (shdr-buf (loc (shdrs@ $obj) $sec-idx (elf64-shdr))) (seg-buf (loc (segs@ $obj) $sec-idx (unit))) (begin
				[memcpy $shdr-buf [+ $objsrc (loc (e-shoff@(ehdr@ $obj)) $sec-idx (e-shentsize@(ehdr@ $obj)))] (elf64-shdr)]
				[set $seg-buf [region-alloc $reg (sh-size@ $shdr-buf)]]
				(if [= (sh-type@ $shdr-buf) (sht-nobits)] (begin)
					[memcpy $seg-buf [+ $objsrc (sh-offset@ $shdr-buf)] (sh-size@ $shdr-buf)])
				(if [= (sh-type@ $shdr-buf) (sht-symtab)]
					(let (symnum [/ (sh-size@ $shdr-buf) (sh-entsize@ $shdr-buf)]) (syms-buf (loc (syms@ $obj) $sec-idx (unit)))
						(begin
						(++ Following code copies recognized information from the symbol table into (syms@ $obj))
						[set $syms-buf [region-alloc $reg [* $symnum (elf64-sym)]]]
						(for (sym-idx &0 $symnum)
							[memcpy (loc $$syms-buf $sym-idx (elf64-sym)) (loc $seg-buf $sym-idx (sh-entsize@ $shdr-buf))
								(elf64-sym)])))
				(if (or [= (sh-type@ $shdr-buf) (sht-rela)] [= (sh-type@ $shdr-buf) (sht-rel)])
					(let (relanum [/ (sh-size@ $shdr-buf) (sh-entsize@ $shdr-buf)]) (relas-buf (loc (syms@ $obj) $sec-idx (unit)))
						(begin
						(++ Following code copies recognized information from the relocations into (relas@ $obj))
						[set $relas-buf [region-alloc $reg [* $relanum (elf64-rela)]]]
						(for (rela-idx &0 $relanum)
							[memcpy (loc $$relas-buf $rela-idx (elf64-rela)) (loc $seg-buf $rela-idx (sh-entsize@ $shdr-buf))
								(if [= (sh-type@ $shdr-buf) (sht-rela)] (elf64-rela) (elf64-rel))]))) (begin))))))
		{return $obj}))))

(let (f [open (" ../bin/x86_64.o)]) (reg [create-region &0])
	(let (buf [region-alloc $reg [size $f]]) (begin
		[read $f $buf [size $f]]
		[read-object $buf [size $f] $reg (null)])))
