(function -storage- (l r) [mk# $r #0])
(function -function- (l r) [mk# $r #1])
(function -with- (l r) [mk# $r #2])
(function -invoke- (l r) [mk# $r #3])
(function -if- (l r) [mk# $r #4])
(function -begin- (l r) [mk# $r #5])
(function -literal- (l r) [mk# $r #6])
(function -reference- (l r) [mk# $r #7])
(function -jump- (l r) [mk# $r #8])
(function -continuation- (l r) [mk# $r #9])
(function -assembly- (l r) [mk# $r #10])
(function -meta- (l r) [mk# $r #11])

(function static-storage (l r) [mk# $r #0])
(function dynamic-storage (l r) [mk# $r #1])

(function local-scope (l r) [mk# $r #0])
(function global-scope (l r) [mk# $r #1])

(function undefined-state (l r) [mk# $r #0])
(function defined-state (l r) [mk# $r #1])

(function symbol (l r) [mk# $r #48])

(function sym-name (l r) [mk-field $l $r #0 #8])
(function sym-offset (l r) [mk-field $l $r #8 #8])
(function sym-size (l r) [mk-field $l $r #16 #8])
(function sym-definition (l r) [mk-field $l $r #24 #8])
(function sym-context (l r) [mk-field $l $r #32 #8])
(function sym-type (l r) [mk-field $l $r #40 #1])
(function sym-scope (l r) [mk-field $l $r #41 #1])
(function sym-state (l r) [mk-field $l $r #42 #1])

(function expression (l r) [mk# $r #64])

(function expr-type (l r) [mk-field $l $r #0 #8])
(function expr-parent (l r) [mk-field $l $r #8 #8])
(function expr-return-symbol (l r) [mk-field $l $r #16 #8])
(;; Only for type(s) (-begin-))
(function expr-expressions (l r) [mk-field $l $r #24 #8])
(;; Only for type(s) (-assembly-))
(function expr-opcode (l r) [mk-field $l $r #24 #8])
(;; Only for type(s) (-assembly-) (-storage-) (-invoke-) (-jump-))
(function expr-arguments (l r) [mk-field $l $r #32 #8])
(;; Only for type(s) (-storage-) (-invoke-) (-jump-) (-function-) (-continuation-) (-with-) (-meta-))
(function expr-reference (l r) [mk-field $l $r #24 #8])
(;; Only for type(s) (-jump-))
(function expr-short-circuit (l r) [mk-field $l $r #40 #8])
(;; Only for type(s) (-if-))
(function expr-condition (l r) [mk-field $l $r #24 #8])
(function expr-consequent (l r) [mk-field $l $r #32 #8])
(function expr-alternate (l r) [mk-field $l $r #40 #8])
(;; Only for type(s) (-literal-))
(function expr-value (l r) [mk-field $l $r #24 #8])
(;; Only for type(s) (-function-) (-continuation-) (-with-))
(function expr-expression (l r) [mk-field $l $r #32 #8])
(function expr-parameters (l r) [mk-field $l $r #40 #8])
(;; Only for type(s) (-function-))
(function expr-symbols (l r) [mk-field $l $r #48 #8])
(function expr-expression-return-symbol (l r) [mk-field $l $r #56 #8])
(;; Only for type(s) (-continuation-) (-with-))
(function expr-cont-instr-ref (l r) [mk-field $l $r #48 #8])
(function expr-escapes (l r) [mk-field $l $r #56 #8])
(;; Only for type(s) (-reference-))
(function expr-name (l r) [mk-field $l $r #24 #8])
(function expr-symbol (l r) [mk-field $l $r #32 #8])
(;; Only for type(s) (-meta-))
(function expr-argument (l r) [mk-field $l $r #32 #8])

(function make-functionN (l r)
	[lllllst (` invoke $r) (` make-function $r) [@fst $l] [list [lst [@frst $l] [@rrrst $l] $r] $r]
		[@frrst $l] [@rrrst $l] $r])

(function make-continuationN (l r)
	[lllllst (` invoke $r) (` make-continuation $r) [@fst $l] [list [lst [@frst $l] [@rrrst $l] $r] $r]
		[@frrst $l] [@rrrst $l] $r])

(function make-asmN (l r)
	[llllst (` invoke $r) (` make-asm $r) [@fst $l] [list [lst [@frst $l] [@rrst $l] $r] $r] [@rrst $l] $r])

(function make-jumpN (l r)
	[llllst (` invoke $r) (` make-jump $r) [@fst $l] [list [lst [@frst $l] [@rrst $l] $r] $r] [@rrst $l] $r])

(function make-invokeN (l r)
	[llllst (` invoke $r) (` make-invoke $r) [@fst $l] [list [lst [@frst $l] [@rrst $l] $r] $r] [@rrst $l] $r])

(function replace-expression (l r)
	(`(let (replace-expression:orig (,[@fst $l]))
		(let (replace-expression:parent (@ expr-parent $$replace-expression:orig))
			(let (replace-expression:repl (,[@frst $l])) (begin
				(setf expr-parent $replace-expression:repl $replace-expression:parent)
				[set $replace-expression:orig $replace-expression:repl]))))$r))

(function put (l r)
	(`(let (put:parent (,[@frst $l])) (put:repl (,[@frrst $l])) (begin
		(setf (,[@fst $l]) $put:parent $put:repl)
		(setf expr-parent $put:repl $put:parent)))$r))

(function build-expression-literal-len (l r) [mk# $r #64])
