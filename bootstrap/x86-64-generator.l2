(function rax  (l r p) [mk# $l $r $p #0])
(function rcx (l r p) [mk# $l $r $p #1])
(function rdx (l r p) [mk# $l $r $p #2])
(function rbx (l r p) [mk# $l $r $p #3])
(function rsp (l r p) [mk# $l $r $p #4])
(function rbp (l r p) [mk# $l $r $p #5])
(function rsi (l r p) [mk# $l $r $p #6])
(function rdi (l r p) [mk# $l $r $p #7])
(function r8 (l r p) [mk# $l $r $p #8])
(function r9 (l r p) [mk# $l $r $p #9])
(function r10 (l r p) [mk# $l $r $p #10])
(function r11 (l r p) [mk# $l $r $p #11])
(function r12 (l r p) [mk# $l $r $p #12])
(function r13 (l r p) [mk# $l $r $p #13])
(function r14 (l r p) [mk# $l $r $p #14])
(function r15 (l r p) [mk# $l $r $p #15])
(function rip (l r p) [mk# $l $r $p #16])

(function leaq-of-mdb-into-reg (l r p) [mk# $l $r $p #17])
(function movq-from-reg-into-mdb (l r p) [mk# $l $r $p #18])
(function jmp-rel (l r p) [mk# $l $r $p #19])
(function movq-mdb-to-reg (l r p) [mk# $l $r $p #20])
(function pushq-reg (l r p) [mk# $l $r $p #21])
(function movq-reg-to-reg (l r p) [mk# $l $r $p #22])
(function subq-imm-from-reg (l r p) [mk# $l $r $p #23])
(function addq-imm-to-reg (l r p) [mk# $l $r $p #24])
(function popq-reg (l r p) [mk# $l $r $p #25])
(function leave (l r p) [mk# $l $r $p #26])
(function ret (l r p) [mk# $l $r $p #27])
(function jmp-to-reg (l r p) [mk# $l $r $p #28])
(function je-rel (l r p) [mk# $l $r $p #29])
(function orq-reg-to-reg (l r p) [mk# $l $r $p #30])
(function movq-imm-to-reg (l r p) [mk# $l $r $p #31])
(function call-reg (l r p) [mk# $l $r $p #32])
(function label (l r p) [mk# $l $r $p #33])
(function stval-add-off-to-ref (l r p) [mk# $l $r $p #34])
(function stval-sub-rip-from-ref (l r p) [mk# $l $r $p #35])

(function word-size (l r p) [mk# $l $r $p #8])
(function cont-size (l r p) [mk# $l $r $p [* #7 (word-size)]])
(function cont-r15 (l r p) [mk# $l $r $p [* #6 (word-size)]])
(function cont-r12 (l r p) [mk# $l $r $p [* #5 (word-size)]])
(function cont-rbx (l r p) [mk# $l $r $p [* #4 (word-size)]])
(function cont-r13 (l r p) [mk# $l $r $p [* #3 (word-size)]])
(function cont-r14 (l r p) [mk# $l $r $p [* #2 (word-size)]])
(function cont-cir (l r p) [mk# $l $r $p [* #1 (word-size)]])
(function cont-rbp (l r p) [mk# $l $r $p [* #0 (word-size)]])

(function vlayout-frames (n r) (with return (begin
	(if (@ expr-return-symbol $n) (begin
		(setf sym-size (@ expr-return-symbol $n) (word-size))
		[prepend (@ expr-return-symbol $n) (&[get-parent-function $n]expr-symbols) $r])
		(begin))
		
	(switch = (@ expr-type $n)
		((-function-) (begin
			(let (parameter-offset [* #7 (word-size)])
				(foreach (t (@ expr-parameters $n)) (begin
					(setf sym-offset (@ expr-symbol $t) $parameter-offset)
					[set parameter-offset [+ $parameter-offset (word-size)]])))
			(let (symbol-offset #0)
				(foreach (u [reverse (@ expr-symbols $n) $r]) (begin
					[set symbol-offset [- $symbol-offset [pad-size (@ sym-size $u) (word-size)]]]
					(setf sym-offset $u $symbol-offset))))))
		
		((-continuation-) (-with-) (begin
			(if (@ expr-escapes $n) (begin
				(setf sym-size (@(@ expr-reference $n)expr-symbol) (cont-size))
				[append (@(@ expr-reference $n)expr-symbol) (&[get-parent-function $n]expr-symbols) $r])
				(begin))
			(foreach (t (@ expr-parameters $n)) (begin
				(setf sym-size (@ expr-symbol $t) (word-size))
				[append (@ expr-symbol $t) (&[get-parent-function $n]expr-symbols) $r]))))
		
		((-storage-) (begin
			(setf sym-size (@(@ expr-reference $n)expr-symbol) [* [length (@ expr-arguments $n)] (word-size)])
			[append (@(@ expr-reference $n)expr-symbol) (&[get-parent-function $n]expr-symbols) $r]))
		
		(begin))
	
	{return $n})))

(function make-load (sym offset dest-reg scratch-reg r) (with return
	(let (c nil) (begin
		(if [= (@ sym-type $sym) (dynamic-storage)]
			(let (op1 [make-literal [+ (@ sym-offset $sym) $offset] $r])
				[append (make-asmN (movq-mdb-to-reg) ($op1 (make-asmN(rbp)()$r) $dest-reg) $r) c $r])
			(begin
				(let (op1 (make-asmN (stval-add-off-to-ref) ([use-symbol $sym $r] [make-literal $offset $r]) $r))
					[append (make-asmN (movq-imm-to-reg) ($op1 $scratch-reg) $r) c $r])
				[append (make-asmN (movq-mdb-to-reg) ([make-literal #0 $r] $scratch-reg $dest-reg) $r) c $r]))
		{return [make-begin $c $r]}))))

(function make-store (src-reg sym offset scratch-reg r) (with return
	(let (c nil) (begin
		(if [= (@ sym-type $sym) (dynamic-storage)]
			(let (op2 [make-literal [+ (@ sym-offset $sym) $offset] $r])
				[append (make-asmN (movq-from-reg-into-mdb) ($src-reg $op2 (make-asmN(rbp)()$r)) $r) c $r])
			(begin
				(let (op1 (make-asmN (stval-add-off-to-ref) ([use-symbol $sym $r] [make-literal $offset $r]) $r))
					[append (make-asmN (movq-imm-to-reg) ($op1 $scratch-reg) $r) c $r])
				[append (make-asmN (movq-from-reg-into-mdb) ($src-reg [make-literal #0 $r] $scratch-reg) $r) c $r]))
		{return [make-begin $c $r]}))))

(function vgenerate-ifs (n r)
	(if [= (@ expr-type $n) (-if-)]
		(with return (let (c nil) (begin
			[append [make-load (@(@ expr-condition $n)expr-symbol) #0 (make-asmN(r10)()$r) (make-asmN(r13)()$r) $r] c $r]
			[append (make-asmN (orq-reg-to-reg) ((make-asmN(r10)()$r) (make-asmN(r10)()$r)) $r) c $r]
			(storage alternate-symbol [make-symbol (static-storage) (local-scope) (defined-state) (null) (null) $r])
			(let (op1 (make-asmN (stval-sub-rip-from-ref) ([use-symbol $alternate-symbol $r]) $r))
				[append (make-asmN (je-rel) ($op1) $r) c $r])
			[append (@ expr-consequent $n) c $r]
			(storage end-symbol [make-symbol (static-storage) (local-scope) (defined-state) (null) (null) $r])
			(let (op1 (make-asmN (stval-sub-rip-from-ref) ([use-symbol $end-symbol $r]) $r))
				[append (make-asmN (jmp-rel) ($op1) $r) c $r])
			[append (make-asmN (label) ([use-symbol $alternate-symbol $r]) $r) c $r]
			[append (@ expr-alternate $n) c $r]
			[append (make-asmN (label) ([use-symbol $end-symbol $r]) $r) c $r]
			{return [make-begin $c $r]})))
		$n))

(function make-load-address (sym dest-reg r) (with return
	(let (c nil) (begin
		(if [= (@ sym-type $sym) (dynamic-storage)]
			(let (op1 [make-literal (@ sym-offset $sym) $r])
				[append (make-asmN (leaq-of-mdb-into-reg) ($op1 (make-asmN(rbp)()) $dest-reg) $r) c $r])
			[append (make-asmN (movq-imm-to-reg) ([use-symbol $sym $r] $dest-reg) $r) c $r])
		{return [make-begin $c $r]}))))

(function vgenerate-storage-expressions (n r)
	(if [= (@ expr-type $n) (-storage-)]
		(with return (let (c nil) (offset #0) (begin
			(foreach (t (@ expr-arguments $n)) (begin
				[append [make-load (@ expr-symbol $t) #0 (make-asmN(r10)()$r) (make-asmN(r13)()$r) $r] c $r]
				[append [make-store (make-asmN(r10)()$r) (@(@ expr-reference $n)expr-symbol) $offset (make-asmN(r13)()$r) $r] c $r]
				[set offset [+ $offset (word-size)]]))
			[append [make-load-address (@(@ expr-reference $n)expr-symbol) (make-asmN(r11)()$r) $r] c $r]
			[append [make-store (make-asmN(r11)()$r) (@ expr-return-symbol $n) #0 (make-asmN(r10)()$r) $r] c $r]
			{return [make-begin $c $r]})))
		$n))

(function vgenerate-references (n r)
	(if (and [= (@ expr-type $n) (-reference-)] (@ expr-return-symbol $n))
		(with return (let (c nil) (begin
			[append [make-load-address (@ expr-symbol $n) (make-asmN(r11)()$r) $r] c $r]
			[append [make-store (make-asmN(r11)()$r) (@ expr-return-symbol $n) #0 (make-asmN(r10)()$r) $r] c $r]
			{return [make-begin $c $r]})))
		$n))

(function cont-instr-ref (n r) (with return (begin
	(if (@ expr-cont-instr-ref $n) (begin)
		(setf expr-cont-instr-ref $n
			[use-symbol [make-symbol (static-storage) (local-scope) (defined-state) (nul) (null) $r] $r]))
	{return (@ expr-cont-instr-ref $n)})))

(function make-store-continuation (n r) (with return (let (c nil) (begin
	[append [make-store (make-asmN(rbx)()$r) (@(@ expr-reference $n)expr-symbol) (cont-rbx) (make-asmN(r11)()$r) $r] c $r]
	[append [make-store (make-asmN(r12)()$r) (@(@ expr-reference $n)expr-symbol) (cont-r12) (make-asmN(r11)()$r) $r] c $r]
	[append [make-store (make-asmN(r13)()$r) (@(@ expr-reference $n)expr-symbol) (cont-r13) (make-asmN(r11)()$r) $r] c $r]
	[append [make-store (make-asmN(r14)()$r) (@(@ expr-reference $n)expr-symbol) (cont-r14) (make-asmN(r11)()$r) $r] c $r]
	[append [make-store (make-asmN(r15)()$r) (@(@ expr-reference $n)expr-symbol) (cont-r15) (make-asmN(r11)()$r) $r] c $r]
	[append [make-load-address (@[cont-instr-ref $n $r]expr-symbol) (make-asmN(r10)()$r) $r] c $r]
	[append [make-store (make-asmN(r10)()$r) (@(@ expr-reference $n)expr-symbol) (cont-cir) (make-asmN(r11)()$r) $r] c $r]
	[append [make-store (make-asmN(rbp)()$r) (@(@ expr-reference $n)expr-symbol) (cont-rbp) (make-asmN(r11)()$r) $r] c $r]
	{return [make-begin $c $r]}))))

(function move-arguments (n offset r) (with return (let (c nil) (begin
	(foreach (t (@ expr-arguments $n)) (begin
		[append [make-load (@ expr-symbol $t) #0 (make-asmN(r10)()$r) (make-asmN(r13)()$r) $r] c $r]
		[append (make-asmN (movq-from-reg-into-mdb)
			((make-asmN(r10)()$r) [make-literal $offset $r] (make-asmN(r11)()$r)) $r) c $r]
		[set offset [+ $offset (word-size)]]))
	{return [make-begin $c $r]}))))

(function vgenerate-continuation-expressions (n r) (with return (let (c nil)
	(switch = (@ expr-type $n)
		((-continuation-) (begin
			[append [make-load-address (if (@ expr-escapes $n) (@(@ expr-reference $n)expr-symbol) [cont-instr-ref $n $r])
				(make-asmN(r11)()$r) $r] c $r]
			[append [make-store (make-asmN(r11)()$r) (@ expr-return-symbol $n) #0 (make-asmN(r10)()$r) $r] c $r]
			(if (@ expr-escapes $n) [append [make-store-continuation $n $r] c $r] (begin))
			(storage after-symbol [make-symbol (static-storage) (local-scope) (defined-state) (nul) (null) $r])
			[append (make-asmN (jmp-rel) ((make-asmN (stval-sub-rip-from-ref) ([use-symbol $after-symbol $r]) $r)) $r) c $r]
			[append (make-asmN (label) ([cont-instr-ref $n $r]) $) c $r]
			[append (@ expr-expression $n) c $r]
			[append (make-asmN (label) ([use-symbol $after-symbol $r]) $r) c $r]
			{return [make-begin $c $r]}))
		
		((-with-) (begin
			(if (@ expr-escapes $n) [append [make-store-continuation $n $r] c $r] (begin))
			[append (@ expr-expression $n) c $r]
			[append (make-asmN (label) ([cont-instr-ref $n $r]) $r) c $r]
			[append [make-load (@[@fst(@ expr-parameters $n)]expr-symbol) #0 (make-asmN(r11)()$r) (make-asmN(r10)()$r) $r] c $r]
			[append [make-store (make-asmN(r11)()$r) (@ expr-return-symbol $n) #0 (make-asmN(r10)()$r) $r] c $r]
			{return [make-begin $c $r]}))
		
		((-jump-) (begin
			(if (@ expr-short-circuit $n)
			(begin
				(if [length (@(@ expr-short-circuit $n)expr-parameters)] (begin
					[append [make-load-address (@ [@fst (@ (@ expr-short-circuit $n) expr-parameters)] expr-symbol)
						(make-asmN(r11)()$r) $r] c $r]
					[append [move-arguments $n #0 $r] c $r])
					(begin))
				[append (make-asmN (jmp-rel) ((make-asmN (stval-sub-rip-from-ref)
					([cont-instr-ref (@ expr-short-circuit $n) $r]) $r)) $r) c $r])
			(begin
				[append [make-load (@(@ expr-reference $n) expr-symbol) #0 (make-asmN(r11)()$r) (make-asmN(r10)()$r) $r] c $r]
				[append [move-arguments $n (cont-size) $r] c $r]
				[append (make-asmN(movq-mdb-to-reg)([make-literal(cont-rbx)$r] (make-asmN(r11)()$r) (make-asmN(rbx)()$r))$r) c $r]
				[append (make-asmN(movq-mdb-to-reg)([make-literal(cont-r12)$r] (make-asmN(r11)()$r) (make-asmN(r12)()$r))$r) c $r]
				[append (make-asmN(movq-mdb-to-reg)([make-literal(cont-r13)$r] (make-asmN(r11)()$r) (make-asmN(r13)()$r))$r) c $r]
				[append (make-asmN(movq-mdb-to-reg)([make-literal(cont-r14)$r] (make-asmN(r11)()$r) (make-asmN(r14)()$r))$r) c $r]
				[append (make-asmN(movq-mdb-to-reg)([make-literal(cont-r15)$r] (make-asmN(r11)()$r) (make-asmN(r15)()$r))$r) c $r]
				[append (make-asmN(movq-mdb-to-reg)([make-literal(cont-cir)$r] (make-asmN(r11)()$r) (make-asmN(r10)()$r))$r) c $r]
				[append (make-asmN(movq-mdb-to-reg)([make-literal(cont-rbp)$r] (make-asmN(r11)()$r) (make-asmN(rbp)()$r))$r) c $r]
				[append (make-asmN(jmp-to-reg)((make-asmN(r10)()$r))$r) c $r]))
			{return [make-begin $c $r]}))
		
		{return $n}))))
				
