(function -rax- (l r p) [mk# $l $r $p #0])
(function -rcx- (l r p) [mk# $l $r $p #1])
(function -rdx- (l r p) [mk# $l $r $p #2])
(function -rbx- (l r p) [mk# $l $r $p #3])
(function -rsp- (l r p) [mk# $l $r $p #4])
(function -rbp- (l r p) [mk# $l $r $p #5])
(function -rsi- (l r p) [mk# $l $r $p #6])
(function -rdi- (l r p) [mk# $l $r $p #7])
(function -r8- (l r p) [mk# $l $r $p #8])
(function -r9- (l r p) [mk# $l $r $p #9])
(function -r10- (l r p) [mk# $l $r $p #10])
(function -r11- (l r p) [mk# $l $r $p #11])
(function -r12- (l r p) [mk# $l $r $p #12])
(function -r13- (l r p) [mk# $l $r $p #13])
(function -r14- (l r p) [mk# $l $r $p #14])
(function -r15- (l r p) [mk# $l $r $p #15])
(function -rip- (l r p) [mk# $l $r $p #16])

(function -leaq-of-mdb-into-reg- (l r p) [mk# $l $r $p #17])
(function -movq-from-reg-into-mdb- (l r p) [mk# $l $r $p #18])
(function -jmp-rel- (l r p) [mk# $l $r $p #19])
(function -movq-mdb-to-reg- (l r p) [mk# $l $r $p #20])
(function -pushq-reg- (l r p) [mk# $l $r $p #21])
(function -movq-reg-to-reg- (l r p) [mk# $l $r $p #22])
(function -subq-imm-from-reg- (l r p) [mk# $l $r $p #23])
(function -addq-imm-to-reg- (l r p) [mk# $l $r $p #24])
(function -popq-reg- (l r p) [mk# $l $r $p #25])
(function -leave- (l r p) [mk# $l $r $p #26])
(function -ret- (l r p) [mk# $l $r $p #27])
(function -jmp-to-reg- (l r p) [mk# $l $r $p #28])
(function -je-rel- (l r p) [mk# $l $r $p #29])
(function -orq-reg-to-reg- (l r p) [mk# $l $r $p #30])
(function -movq-imm-to-reg- (l r p) [mk# $l $r $p #31])
(function -call-reg- (l r p) [mk# $l $r $p #32])
(function -label- (l r p) [mk# $l $r $p #33])
(function -stval-add-off-to-ref- (l r p) [mk# $l $r $p #34])
(function -stval-sub-rip-from-ref- (l r p) [mk# $l $r $p #35])

(function -word-size- (l r p) [mk# $l $r $p #8])
(function -cont-size- (l r p) [mk# $l $r $p [* #7 (-word-size-)]])
(function -cont-r15- (l r p) [mk# $l $r $p [* #6 (-word-size-)]])
(function -cont-r12- (l r p) [mk# $l $r $p [* #5 (-word-size-)]])
(function -cont-rbx- (l r p) [mk# $l $r $p [* #4 (-word-size-)]])
(function -cont-r13- (l r p) [mk# $l $r $p [* #3 (-word-size-)]])
(function -cont-r14- (l r p) [mk# $l $r $p [* #2 (-word-size-)]])
(function -cont-cir- (l r p) [mk# $l $r $p [* #1 (-word-size-)]])
(function -cont-rbp- (l r p) [mk# $l $r $p [* #0 (-word-size-)]])

(function vlayout-frames (n r) (with return (begin
	(if (@ $n expr-return-symbol) (begin
		(setf (@ $n expr-return-symbol) sym-size (-word-size-))
		[prepend (@ $n expr-return-symbol) (&[get-parent-function $n]expr-symbols) $r])
		(begin))
		
	(switch = (@ $n expr-type)
		((-function-) (begin
			(let (parameter-offset [* #7 (-word-size-)])
				(foreach (t (@ $n expr-parameters)) (begin
					(setf (@ $t expr-symbol) sym-offset $parameter-offset)
					[set parameter-offset [+ $parameter-offset (-word-size-)]])))
			(let (symbol-offset #0)
				(foreach (u [reverse (@ $n expr-symbols) $r]) (begin
					[set symbol-offset [- $symbol-offset [pad-size (@ $u sym-size) (-word-size-)]]]
					(setf $u sym-offset $symbol-offset))))))
		
		((-continuation-) (-with-) (begin
			(if (@ $n expr-escapes) (begin
				(setf (@(@ $n expr-reference)expr-symbol) sym-size (-cont-size-))
				[append (@(@ $n expr-reference)expr-symbol) (&[get-parent-function $n]expr-symbols) $r])
				(begin))
			(foreach (t (@ $n expr-parameters)) (begin
				(setf (@ $t expr-symbol) sym-size (-word-size-))
				[append (@ $t expr-symbol) (&[get-parent-function $n]expr-symbols) $r]))))
		
		((-storage-) (begin
			(setf (@(@ $n expr-reference)expr-symbol) sym-size [* [length (@ $n expr-arguments)] (-word-size-)])
			[append (@(@ $n expr-reference)expr-symbol) (&[get-parent-function $n]expr-symbols) $r]))
		
		(begin))
	
	{return $n})))

(function make-load (sym offset dest-reg scratch-reg r) (with return
	(let (container nil) (begin
		(if [= (@ $sym sym-type) (-dynamic-storage-)]
			(let (op1 [make-literal [+ (@ $sym sym-offset) $offset] $r])
				[append (make-asmN (-movq-mdb-to-reg-) ($op1 (make-asmN(-rbp-)()$r) $dest-reg) $r) container $r])
			(begin
				(let (op1 (make-asmN (-stval-add-off-to-ref-) ([use-symbol $sym $r] [make-literal $offset $r]) $r))
					[append (make-asmN (-movq-imm-to-reg-) ($op1 $scratch-reg) $r) container $r])
				[append (make-asmN (-movq-mdb-to-reg-) ([make-literal #0 $r] $scratch-reg $dest-reg) $r) container $r]))
		{return [make-begin $container $r]}))))

(function make-store (src-reg sym offset scratch-reg r) (with return
	(let (container nil) (begin
		(if [= (@ $sym sym-type) (-dynamic-storage-)]
			(let (op2 [make-literal [+ (@ $sym sym-offset) $offset] $r])
				[append (make-asmN (-movq-from-reg-into-mdb-) ($src-reg $op2 (make-asmN(-rbp-)()$r)) $r) container $r])
			(begin
				(let (op1 (make-asmN (-stval-add-off-to-ref-) ([use-symbol $sym $r] [make-literal $offset $r]) $r))
					[append (make-asmN (-movq-imm-to-reg-) ($op1 $scratch-reg) $r) container $r])
				[append (make-asmN (-movq-from-reg-into-mdb-) ($src-reg [make-literal #0 $r] $scratch-reg) $r) container $r]))
		{return [make-begin $container $r]}))))

(function vgenerate-ifs (n r)
	(if [= (@ $n expr-type) (-if-)]
		(with return (let (c nil) (begin
			[append [make-load (@(@ $n expr-condition)expr-symbol) #0 (make-asmN(-r10-)()$r) (make-asmN(-r13-)()$r) $r] c $r]
			[append (make-asmN (-orq-reg-to-reg-) ((make-asmN(-r10-)()$r) (make-asmN(-r10-)()$r)) $r) c $r]
			(storage alternate-symbol [make-symbol (-static-storage-) (-local-scope-) (-defined-state-) (null) (null) $r])
			(let (op1 (make-asmN (-stval-sub-rip-from-ref-) ([use-symbol $alternate-symbol $r]) $r))
				[append (make-asmN (-je-rel-) ($op1) $r) c $r])
			[append (@ $n expr-consequent) c $r]
			(storage end-symbol [make-symbol (-static-storage-) (-local-scope-) (-defined-state-) (null) (null) $r])
			(let (op1 (make-asmN (-stval-sub-rip-from-ref-) ([use-symbol $end-symbol $r]) $r))
				[append (make-asmN (-jmp-rel-) ($op1) $r) c $r])
			[append (make-asmN (-label-) ([use-symbol $alternate-symbol $r]) $r) c $r]
			[append (@ $n expr-alternate) c $r]
			[append (make-asmN (-label-) ([use-symbol $end-symbol $r]) $r) c $r]
			{return [make-begin $c $r]})))
		$n))

(function make-load-address (sym dest-reg r) (with return
	(let (c nil) (begin
		(if [= (@ $sym sym-type) (-dynamic-storage-)]
			(let (op1 [make-literal (@ $sym sym-offset) $r])
				[append (make-asmN (-leaq-of-mdb-into-reg-) ($op1 (make-asmN(-rbp-)()) $dest-reg) $r) c $r])
			[append (make-asmN (-movq-imm-to-reg-) ([use-symbol $sym $r] $dest-reg) $r) c $r])
		{return [make-begin $c $r]}))))

(function vgenerate-storage-expressions (n r)
	(if [= (@ $n expr-type) (-storage-)]
		(with return (let (c nil) (offset #0) (begin
			(foreach (t (@ $n expr-arguments)) (begin
				[append [make-load (@ $t expr-symbol) #0 (make-asmN(-r10-)()$r) (make-asmN(-r13-)()$r) $r] c $r]
				[append [make-store (make-asmN(-r10-)()$r) (@(@ $n expr-reference)expr-symbol) $offset (make-asmN(-r13-)()$r) $r] c $r]
				[set offset [+ $offset (-word-size-)]]))
			[append [make-load-address (@(@ $n expr-reference)expr-symbol) (make-asmN(-r11-)()$r) $r] c $r]
			[append [make-store (make-asmN(-r11-)()$r) (@ $n expr-return-symbol) #0 (make-asmN(-r10-)()$r) $r] c $r]
			{return [make-begin $c $r]})))
		$n))

(function vgenerate-references (n r)
	(if (and [= (@ $n expr-type) (-reference-)] (@ $n expr-return-symbol))
		(with return (let (c nil) (begin
			[append [make-load-address (@ $n expr-symbol) (make-asmN(-r11-)()$r) $r] c $r]
			[append [make-store (make-asmN(-r11-)()$r) (@ $n expr-return-symbol) #0 (make-asmN(-r10-)()$r) $r] c $r]
			{return [make-begin $c $r]})))
		$n))

(function cont-instr-ref (n r) (with return (begin
	(if (@ $n expr-cont-instr-ref) (begin)
		(setf $n expr-cont-instr-ref
			[use-symbol [make-symbol (-static-storage-) (-local-scope-) (-defined-state-) (nul) (null) $r] $r]))
	{return (@ $n expr-cont-instr-ref)})))
