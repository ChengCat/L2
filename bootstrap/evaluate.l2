(function load-expressions (program ectx) (do-let (with return (begin
		(storage ct-reg (@ ectx-expr-buf $ectx))
		[visit-expressions vfind-multiple-definitions program $handler]
		[classify-program-symbols (@ expr-expression $program)]
		[visit-expressions vlink-references (& expr-expression $program) (storage _ $handler $ct-reg)]
		[set program [use-return-symbol $program (null) $ct-reg]]
		[classify-program-symbols (@ expr-expression $program)]
		[visit-expressions vlayout-frames (& expr-expression $program) $ct-reg]
		[visit-expressions vgenerate-references program $ct-reg]
		[visit-expressions vgenerate-continuation-expressions program $ct-reg]
		[visit-expressions vgenerate-literals program $ct-reg]
		[visit-expressions vgenerate-ifs program $ct-reg]
		[visit-expressions vgenerate-function-expressions program $ct-reg]
		[visit-expressions vgenerate-storage-expressions program $ct-reg]
		(storage symbols (@ expr-symbols $program))
		(foreach (l (@ expr-parameters $program)) [prepend (@ expr-symbol $l) symbols $ct-reg])
		[set program [generate-toplevel $program $ct-reg]]
		(storage asms nil)
		[visit-expressions vlinearized-expressions program (storage _ asms $ct-reg)]
		[set asms [reverse $asms $ct-reg]]
		(storage objdest (begin))
		(storage objdest-sz (begin))
		[write-elf $asms $symbols objdest objdest-sz $ct-reg]
		(storage obj [load $objdest $objdest-sz (@ ectx-obj-buf $ectx) (@ ectx-handler $ectx)])
		[symbol-offsets-to-addresses $asms $symbols $obj]
		{return $obj}))
	(handler (continuation _ (code arg0 arg1 arg2 arg3) (begin
		(switch = $code
			(multiple-definition-error [write-str (stdout) (" Multiple definition error.)])
			(param-count-mismatch-error [write-str (stdout) (" Parameter count mismatch error.)])
			(begin))
		[exit #1])))))

(function evaluate-files (srcv bindings handler) (begin
	(storage objects nil)
	(storage obj-buf [create-buffer #0])
	(storage expr-buf [create-buffer #0])
	(storage ectx $bindings $obj-buf $handler $expr-buf)
	
	(foreach (src $srcv) (begin
		(storage obj (begin))
		(storage dot [strrchr $src (char .)])
		
		(if (and $dot [str= $dot (" .l2)]) (begin
			(storage fd [open $src])
			(storage src-sz [size $fd])
			(storage src-buf [buffer-alloc $expr-buf $src-sz])
			[read $fd $src-buf $src-sz]
			[close $fd]
			
			(storage expressions nil)
			(storage pos #0)
			(while [after-leading-space $src-buf $src-sz pos]
				[append [build-expression [build-fragment $src-buf $src-sz pos $expr-buf $handler] $expr-buf $handler]
					expressions $expr-buf])
			[set obj [load-expressions [generate-metaprogram [make-program $expressions $expr-buf] ectx] ectx]])
			
		(if (and $dot [str= $dot (" .o)]) (begin
			(storage obj-fd [open $src])
			(storage obj-sz [size $obj-fd])
			(storage buf [buffer-alloc $obj-buf $obj-sz])
			[read $obj-fd $buf $obj-sz]
			[close $obj-fd]
			[set obj [load $buf $obj-sz $obj-buf $handler]])
			
			(begin)))
		
		[append $obj objects $obj-buf]
		[append-list (& ectx-symbols $ectx) [immutable-symbols $obj $obj-buf]]))
	
	(foreach (obj $objects) [mutate-symbols $obj (@ ectx-symbols $ectx)])
	(foreach (obj $objects) [[segment $obj (" .text)]])
	
	[destroy-buffer $expr-buf]
	[destroy-buffer $obj-buf]))

(let (r [create-buffer #0])
	[evaluate-files [@cdr[argv $r]] nil (null)])
