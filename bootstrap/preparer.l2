(function defined-str= (a b) (and $a $b [str= $a $b]))

(function named-ref= (a b) [defined-str= (@ expr-name $a) (@ expr-name $b)])

(storage multiple-definition-error #0)

(function vfind-multiple-definitions (e handler) (with return
	(switch = (@ expr-type $e)
		((-begin-) (let (temp-reg [create-buffer #0]) (begin
			(let (definitions [filter (function _ (f) (or [= (@ expr-type $f) (-storage-)] [= (@ expr-type $f) (-function-)]))
					(@ expr-expressions $e) $temp-reg])
				(until (partial $definitions) [nil? $partial] [@cdr $partial]
					(if [find (function _ (f ctx) [named-ref= (@ expr-reference $f) (@ expr-reference $ctx)])
							(& cdr $partial) [@car $partial]]
						{$handler multiple-definition-error (@ expr-name(@ expr-reference[@car $partial]))}
						(begin))))
			[destroy-buffer $temp-reg]
			{return $e})))
		
		((-continuation-) (-function-) (let (temp-reg [create-buffer #0]) (begin
			(let (ref-with-params [lst (@ expr-reference $e) (@ expr-parameters $e) $temp-reg])
				(until (partial $ref-with-params) [nil? $partial] [@cdr $partial]
					(if [find (function _ (f ctx) [named-ref= $f $ctx]) (& cdr $partial) [@car $partial]]
						{$handler multiple-definition-error (@ expr-name[@car $partial])}
						(begin))))
			[destroy-buffer $temp-reg]
			{return $e})))
		
		{return $e})))

(function get-parent-function (n) (with return
	{(continuation loop (n)
		(if [= (@ expr-type $n) (-function-)]
			{return $n}
			{loop (@ expr-parent $n)})) (@ expr-parent $n)}))

(function symbol-of (reference) (with return (begin
	(let (same-func (true))
		(until (t $reference) [= $t (null)] (@ expr-parent $t)
			(switch = (@ expr-type $t)
				((-begin-) (foreach (u (@ expr-expressions $t))
					(if (and (or [= (@ expr-type $u) (-function-)] (and [= (@ expr-type $u) (-storage-)] (or $same-func
							[= (@ sym-type(@ expr-symbol(@ expr-reference $u))) (static-storage)])))
							[named-ref= (@ expr-reference $u) $reference])
						{return (@ expr-symbol(@ expr-reference $u))}
						(begin))))
				
				((-function-) (begin
					(if [named-ref= (@ expr-reference $t) $reference]
						{return (@ expr-symbol(@ expr-reference $t))}
						(foreach (u (@ expr-parameters $t))
							(if (and (or $same-func [= (@ sym-type(@ expr-symbol $u)) (static-storage)]) [named-ref= $u $reference])
								{return (@ expr-symbol $u)}
								(begin))))
					[set same-func (false)]))
				
				((-continuation-) (-with-) (-storage-)
					(if (and (or $same-func [= (@ sym-type(@ expr-symbol(@ expr-reference $t))) (static-storage)])
							[named-ref= (@ expr-reference $t) $reference])
						{return (@ expr-symbol(@ expr-reference $t))}
					(if [= (@ expr-type $t) (-storage-)] (begin)
						(foreach (u (@ expr-parameters $t))
							(if (and (or $same-func [= (@ sym-type(@ expr-symbol $u)) (static-storage)]) [named-ref= $u $reference])
								{return (@ expr-symbol $u)}
								(begin))))))
				
				(begin))))
	{return (null)})))

(function jump-reference? (s) (and [= (@ expr-type(@ expr-parent $s)) (-jump-)] [= (@ expr-reference(@ expr-parent $s)) $s]))

(function invoke-reference? (s) (and [= (@ expr-type(@ expr-parent $s)) (-invoke-)] [= (@ expr-reference(@ expr-parent $s)) $s]))

(function function-reference? (s) (and [= (@ expr-type(@ expr-parent $s)) (-function-)] [= (@ expr-reference(@ expr-parent $s)) $s]))

(function c-reference? (s)
	(and (or [= (@ expr-type(@ expr-parent $s)) (-continuation-)] [= (@ expr-type(@ expr-parent $s)) (-with-)])
		[= (@ expr-reference(@ expr-parent $s)) $s]))

(function get-target-expression (s) (@ expr-parent(@ sym-definition(@ expr-symbol $s))))

(function get-root-function (s) (with return
	{(continuation loop (s parent)
		(if $parent
			{loop $parent (@ expr-parent $parent)}
			{return $s})) $s (@ expr-parent $s)}))

(storage param-count-mismatch-error #0)

(function vlink-references (s ctx)
	(let (handler ($(loc $ctx #0(unit)))) (r ($(loc $ctx #1(unit))))
		(if [= (@ expr-type $s) (-reference-)]
			(with return (begin
				(setf expr-symbol $s (if (@ expr-symbol $s) (@ expr-symbol $s) [symbol-of $s]))
				(if (not (@ expr-symbol $s))
					(let (ref [make-reference (@ expr-name $s) $r]) (rf [get-root-function $s])
						(let (sym [make-symbol (static-storage) (global-scope) (undefined-state) (@ expr-name $s) $ref $r]) (begin
							(setf expr-symbol $ref $sym)
							(setf expr-parameters $rf [cons $ref (@ expr-parameters $rf) $r])
							(setf expr-parent $ref $rf)
							(setf expr-symbol $s $sym)
							{return $s})))
				(if (and (or (and [jump-reference? $s] [c-reference? (@ sym-definition(@ expr-symbol $s))])
						(and [invoke-reference? $s] [function-reference? (@ sym-definition(@ expr-symbol $s))]))
						(not [= [length(@ expr-arguments(@ expr-parent $s))] [length(@ expr-parameters[get-target-expression $s])]]))
					{$handler param-count-mismatch-error (@ expr-parent $s) [get-target-expression $s]}
					{return $s}))))
		(if (and (or (and [= (@ expr-type $s) (-continuation-)] [jump-reference? $s])
				(and [= (@ expr-type $s) (-function-)] [invoke-reference? $s]))
				(not [= [length (@ expr-arguments(@ expr-parent $s))] [length (@ expr-parameters $s)]]))
			{$handler param-count-mismatch-error (@ expr-parent $s) $s}
			$s))))

(function vescape-analysis-aux (ref target)
	(if [jump-reference? $ref]
		(setf expr-short-circuit (@ expr-parent $ref) $target)
		(setf expr-escapes $target (true))))

(function vescape-analysis (s ctx) (with return (begin
	(if (and [= (@ expr-type $s) (-reference-)] (not [= (@ sym-definition(@ expr-symbol $s)) $s])
			[c-reference? (@ sym-definition(@ expr-symbol $s))])
		[vescape-analysis-aux $s [get-target-expression $s]]
		[vescape-analysis-aux $s $s])
	{return $s})))

(function visit-expressions (visitor s ctx) (begin
	(switch = (@ expr-type $$s)
		((-begin-)
			(until (partial (@ expr-expressions $$s)) [nil? $partial] [@cdr $partial]
				[visit-expressions $visitor (& car $partial) $ctx]))
		
		((-if-) (begin
			[visit-expressions $visitor (& expr-condition $$s) $ctx]
			[visit-expressions $visitor (& expr-consequent $$s) $ctx]
			[visit-expressions $visitor (& expr-alternate $$s) $ctx]))
		
		((-function-) (-continuation-) (-with-)
			[visit-expressions $visitor (& expr-expression $$s) $ctx])
		
		((-jump-) (-invoke-) (-storage-) (begin
			(if [= (@ expr-type $$s) (-storage-)] (begin) [visit-expressions $visitor (& expr-reference $$s) $ctx])
			(until (partial (@ expr-arguments $$s)) [nil? $partial] [@cdr $partial]
				[visit-expressions $visitor (& car $partial) $ctx])))
		
		(begin))
	(replace-expression $s [$visitor $$s $ctx])))

(function use-return-symbol (n ret-sym r) (with return
	(switch = (@ expr-type $n)
		((-with-) (-continuation-) (begin
			(setf expr-return-symbol $n $ret-sym)
			(put expr-expression $n [use-return-symbol (@ expr-expression $n)
				[make-symbol (dynamic-storage) (local-scope) (defined-state) (null) (null) $r] $r])
			{return $n}))
		
		((-function-) (begin
			(setf expr-return-symbol $n $ret-sym)
			(setf expr-expression-return-symbol $n [make-symbol (dynamic-storage) (local-scope) (defined-state) (null) (null) $r])
			(put expr-expression $n [use-return-symbol (@ expr-expression $n) (@ expr-expression-return-symbol $n) $r])
			{return $n}))
		
		((-invoke-) (-jump-) (-storage-)
			(let (container nil) (begin
				(if [= (@ expr-type $n) (-storage-)] (begin)
					(let (ref-ret-sym [make-symbol (dynamic-storage) (local-scope) (defined-state) (null) (null) $r]) (begin
						[append [use-return-symbol (@ expr-reference $n) $ref-ret-sym $r] container $r]
						(put expr-reference $n [use-symbol $ref-ret-sym $r]))))
						
				(until (partial (@ expr-arguments $n)) [nil? $partial] [@cdr $partial]
					(let (arg-ret-sym [make-symbol (dynamic-storage) (local-scope) (defined-state) (null) (null) $r]) (begin
						[append [use-return-symbol [@car $partial] $arg-ret-sym $r] container $r]
						(replace-expression (& car $partial) [use-symbol $arg-ret-sym $r]))))
				
				(setf expr-return-symbol $n $ret-sym)
				[append $n container $r]
				{return [make-begin $container $r]})))
		
		((-if-) (let (container nil) (begin
			(put expr-consequent $n [use-return-symbol (@ expr-consequent $n) $ret-sym $r])
			(put expr-alternate $n [use-return-symbol (@ expr-alternate $n) $ret-sym $r])
			(let (cond-ret-sym [make-symbol (dynamic-storage) (local-scope) (defined-state) (null) (null) $r]) (begin
				[append [use-return-symbol (@ expr-condition $n) $cond-ret-sym $r] container $r]
				(put expr-condition $n [use-symbol $cond-ret-sym $r])
				[append $n container $r]))
			{return [make-begin $container $r]})))
		
		((-begin-) (begin
			(until (partial (@ expr-expressions $n)) [nil? $partial] [@cdr $partial]
				(replace-expression (& car $partial) [use-return-symbol [@car $partial]
					[make-symbol (dynamic-storage) (local-scope) (defined-state) (null) (null) $r] $r]))
			{return $n}))
		
		((-reference-) (-literal-) (begin
			(setf expr-return-symbol $n $ret-sym)
			{return $n}))
		
		{return $n})))

(function vlinearized-expressions (n ctx)
	(if [= (@ expr-type $n) (-begin-)]
		$n
		(with return
			(let (l ($(loc $ctx #0(unit)))) (r ($(loc $ctx #1(unit)))) (begin
				[prepend $n $l $r]
				{return $n})))))

(function prepend-binding (ref binds rt-reg) (if (@ expr-name $ref) [prepend (@ expr-symbol $ref) $binds $rt-reg] (begin)))

(function store-lexical-environment (s is-static static-symbols dynamic-symbols rt-reg)
	(switch = (@ expr-type $s)
		((-begin-) (begin
			(foreach (expr (@ expr-expressions $s))
				(if (or [= (@ expr-type $expr) (-function-)] (and [= (@ expr-type $expr) (-storage-)] $is-static))
					[prepend-binding (@ expr-reference $expr) static-symbols $rt-reg]
				(if [= (@ expr-type $expr) (-storage-)]
					[prepend-binding (@ expr-reference $expr) dynamic-symbols $rt-reg]
					(begin))))
			(foreach (exprr (@ expr-expressions $s))
				[store-lexical-environment $exprr $is-static $static-symbols $dynamic-symbols $rt-reg])))
		
		((-if-) (begin
			[store-lexical-environment (@ expr-condition $s) $is-static $static-symbols $dynamic-symbols $rt-reg]
			[store-lexical-environment (@ expr-consequent $s) $is-static $static-symbols $dynamic-symbols $rt-reg]
			[store-lexical-environment (@ expr-alternate $s) $is-static $static-symbols $dynamic-symbols $rt-reg]))
		
		((-function-) (begin
			[prepend-binding (@ expr-reference $s) static-symbols $rt-reg]
			[set dynamic-symbols nil]
			(foreach (param (@ expr-parameters $s)) [prepend-binding $param dynamic-symbols $rt-reg])
			[store-lexical-environment (@ expr-expression $s) (false) $static-symbols $dynamic-symbols $rt-reg]))
		
		((-continuation-) (-with-) (begin
			[prepend-binding (@ expr-reference $s) (if $is-static static-symbols dynamic-symbols) $rt-reg]
			(foreach (param (@ expr-parameters $s)) [prepend-binding $param (if $is-static static-symbols dynamic-symbols) $rt-reg])
			[store-lexical-environment (@ expr-expression $s) $is-static $static-symbols $dynamic-symbols $rt-reg]))
		
		((-storage-) (begin
			[prepend-binding (@ expr-reference $s) (if $is-static static-symbols dynamic-symbols) $rt-reg]
			(foreach (arg (@ expr-arguments $s)) [store-lexical-environment $arg $is-static $static-symbols $dynamic-symbols $rt-reg])))
		
		((-invoke-) (-jump-) (begin
			[store-lexical-environment (@ expr-reference $s) $is-static $static-symbols $dynamic-symbols $rt-reg]
			(foreach (arg (@ expr-arguments $s)) [store-lexical-environment $arg $is-static $static-symbols $dynamic-symbols $rt-reg])))
		
		((-non-primitive-) (begin
			[store-lexical-environment (@ expr-reference $s) $is-static $static-symbols $dynamic-symbols $rt-reg]
			(setf expr-dynamic-context $s (not $is-static))
			(setf expr-static-symbols $s $static-symbols)
			(setf expr-dynamic-symbols $s [concat $dynamic-symbols (@ expr-dynamic-symbols $s) $rt-reg])))
		
		(begin)))

(function classify-program-symbols (expr) (begin
	(if (@ expr-return-symbol $expr) (setf sym-type (@ expr-return-symbol $expr) (static-storage)) (begin))
	(switch = (@ expr-type $expr)
		((-begin-) (foreach (t (@ expr-expressions $expr)) [classify-program-symbols $t]))
		
		((-storage-) (-jump-) (-invoke-) (begin
			(if [= (@ expr-type $expr) (-storage-)]
				(setf sym-type (@ expr-symbol(@ expr-reference $expr)) (static-storage))
				[classify-program-symbols (@ expr-reference $expr)])
			(foreach (t (@ expr-arguments $expr)) [classify-program-symbols $t])))
		
		((-non-primitive-) [classify-program-symbols (@ expr-reference $expr)])
		
		((-continuation-) (-with-) (begin
			(setf sym-type (@ expr-symbol(@ expr-reference $expr)) (static-storage))
			(foreach (t (@ expr-parameters $expr)) (setf sym-type (@ expr-symbol $t) (static-storage)))
			[classify-program-symbols (@ expr-expression $expr)]))
		
		((-if-) (begin
			[classify-program-symbols (@ expr-condition $expr)]
			[classify-program-symbols (@ expr-consequent $expr)]
			[classify-program-symbols (@ expr-alternate $expr)]))
		
		(begin))))

(function symbol-offset (expansion-container-func sym) (with return
	{(continuation loop (dyn-ancestor offset)
			(if [= $dyn-ancestor (@ sym-function $sym)]
				{return [+ $offset (@ sym-offset $sym)]}
				{loop (@ expr-dynamic-parent $dyn-ancestor) [+ $offset (@ expr-frame-offset $dyn-ancestor)]}))
		(@ expr-dynamic-parent $expansion-container-func) (@ expr-frame-offset $expansion-container-func)}))

(function resolve-dynamic-refs (expr sym reg) (with return
	(switch = (@ expr-type $expr)
		((-reference-)
			{return (if [defined-str= (@ expr-name $expr) (@ sym-name $sym)]
				(make-invokeN [make-literal addfp $reg] ((make-invokeN [make-literal symbol-offset $reg]
					([make-literal [get-parent-function $expr] $reg] [make-literal $sym $reg]) $reg)) $reg)
				$expr)})
		
		((-if-) (begin
			(put expr-condition $expr [resolve-dynamic-refs (@ expr-condition $expr) $sym $reg])
			(put expr-consequent $expr [resolve-dynamic-refs (@ expr-consequent $expr) $sym $reg])
			(put expr-alternate $expr [resolve-dynamic-refs (@ expr-alternate $expr) $sym $reg])
			{return $expr}))
		
		((-begin-) (begin
			(foreach (f (@ expr-expressions $expr))
				(if (and (or [= (@ expr-type $f) (-function-)] [= (@ expr-type $f) (-storage-)])
					[defined-str= (@ expr-name(@ expr-reference $f)) (@ sym-name $sym)]) {return $expr} (begin)))
			(until (partial (@ expr-expressions $expr)) [nil? $partial] [@cdr $partial]
				(replace-expression (& car $partial) [resolve-dynamic-refs [@car $partial] $sym $reg]))
			{return $expr}))
		
		((-continuation-) (-with-) (begin
			(if [defined-str= (@ expr-name(@ expr-reference $expr)) (@ sym-name $sym)] {return $expr} (begin))
			(foreach (e (@ expr-parameters $expr))
				(if [defined-str= (@ expr-name $e) (@ sym-name $sym)] {return $expr} (begin)))
			(put expr-expression $expr [resolve-dynamic-refs (@ expr-expression $expr) $sym $reg])
			{return $expr}))
		
		((-invoke-) (-jump-) (-storage-) (begin
			(if [= (@ expr-type $expr) (-storage-)] (begin)
				(put expr-reference $expr [resolve-dynamic-refs (@ expr-reference $expr) $sym $reg]))
			(until (partial (@ expr-arguments $expr)) [nil? $partial] [@cdr $partial]
				(replace-expression (& car $partial) [resolve-dynamic-refs [@car $partial] $sym $reg]))
			{return $expr}))
		
		((-non-primitive-) (begin
			[prepend $sym (& expr-dynamic-symbols $expr) $reg]
			{return $expr}))
		
		{return $expr})))

(function expansion-context (l r) [mk# $l $r #24])
(function ectx-ext-binds (l r) [mk-field $l $r #0 #8])
(function ectx-rt-reg (l r) [mk-field $l $r #8 #8])
(function ectx-ext-handler (l r) [mk-field $l $r #16 #8])

(function dynamic-np-expansion () (begin))

(function static-np-expansion () (begin))

(function generate-np-expressions (s ct-reg ectx)
	(switch = (@ expr-type $$s)
		((-begin-)
			(until (partial (@ expr-expressions $$s)) [nil? $partial] [@cdr $partial]
				[generate-np-expressions (& car $partial) $ct-reg $ectx]))
				
		((-with-) (-function-) (-continuation-)
			[generate-np-expressions (& expr-expression $$s) $ct-reg $ectx])
			
		((-if-) (begin
			[generate-np-expressions (& expr-condition $$s) $ct-reg $ectx]
			[generate-np-expressions (& expr-consequent $$s) $ct-reg $ectx]
			[generate-np-expressions (& expr-alternate $$s) $ct-reg $ectx]))
		
		((-invoke-) (-jump-) (-storage-) (begin
			(if [= (@ expr-type $$s) (-storage-)] (begin)
				[generate-np-expressions (& expr-reference $$s) $ct-reg $ectx])
			(until (partial (@ expr-arguments $$s)) [nil? $partial] [@cdr $partial]
				[generate-np-expressions (& car $partial) $ct-reg $ectx])))
		
		((-non-primitive-) (begin
			[generate-np-expressions (& expr-reference $$s) $ct-reg $ectx]
			(storage rt-reg (@ ectx-rt-reg $ectx))
			(storage macro-cache [buffer-alloc $rt-reg (unit)])
			[set $macro-cache (null)]
			(storage callee-cont-param [make-reference (null) $ct-reg])
			(storage cont (make-continuationN [make-reference (null) $ct-reg] ($callee-cont-param) [make-begin nil $ct-reg] $ct-reg))
			(storage parent-function [get-parent-function $$s])
			
			(storage wth [make-with [make-reference (null) $ct-reg] (if (@ expr-dynamic-context $$s)
				(make-invokeN (make-invokeN [make-literal dynamic-np-expansion $ct-reg] ((@ expr-reference $$s)
					[make-literal [copy-fragment (@ expr-argument $$s) $rt-reg] $ct-reg] [make-literal $ectx $ct-reg]
					[make-literal (@ expr-static-symbols $$s) $ct-reg] [make-literal parent-function $ct-reg]
					[make-literal (@ expr-dynamic-symbols $$s) $ct-reg] [make-literal $macro-cache $ct-reg]) $ct-reg) ($cont) $ct-reg)
				(make-jumpN $cont ((make-invokeN
					[make-literal static-np-expansion $ct-reg] ((@ expr-reference $$s)
					[make-literal [copy-fragment (@ expr-argument $$s) $rt-reg] $ct-reg] [make-literal $ectx $ct-reg]
					[make-literal (@ expr-static-symbols $$s) $ct-reg] [make-literal $macro-cache $ct-reg]) $ct-reg)) $ct-reg))
				$ct-reg])
			
			(storage macro-invocation [make-with [make-reference (null) $ct-reg] [make-begin nil $ct-reg] $ct-reg])
			(setf expr-parent $macro-invocation (@ expr-parent $$s))
			(storage invoke-return-with-ref-arg [make-reference (null) $ct-reg])
			[refer-reference $invoke-return-with-ref-arg (@ expr-reference $macro-invocation)]
			(storage callee-cont-arg [make-reference (null) $ct-reg])
			[refer-reference $callee-cont-arg $callee-cont-param]
			(put expr-expression $macro-invocation (make-jumpN (make-invokeN [make-literal get $ct-reg] ($callee-cont-arg) $ct-reg)
				($invoke-return-with-ref-arg) $ct-reg))
			[set $s $macro-invocation]
			
			(storage return-with-ref-arg [make-reference (null) $ct-reg])
			[refer-reference $return-with-ref-arg (@ expr-reference $wth)]
			(put expr-expression $cont (make-jumpN $return-with-ref-arg ((@ expr-expression $parent-function)) $ct-reg))
			(put expr-expression $parent-function $wth)))
		
		(begin)))

(function load-expressions (program ectx static-symbols ct-reg) (do-let (begin
		[store-lexical-environment (@ expr-expression $program) (true) $static-symbols nil $ct-reg]
		[generate-np-expressions program $ct-reg (storage _ nil $ct-reg (null))]
		[visit-expressions vfind-multiple-definitions program $handler]
		[classify-program-symbols (@ expr-expression $program)]
		[visit-expressions vlink-references (& expr-expression $program) (storage _ $handler $ct-reg)]
		[set program [use-return-symbol $program (null) $ct-reg]]
		[classify-program-symbols (@ expr-expression $program)]
		[visit-expressions vlayout-frames (& expr-expression $program) $ct-reg]
		[visit-expressions vgenerate-references program $ct-reg]
		[visit-expressions vgenerate-continuation-expressions program $ct-reg]
		[visit-expressions vgenerate-literals program $ct-reg]
		[visit-expressions vgenerate-ifs program $ct-reg]
		[visit-expressions vgenerate-function-expressions program $ct-reg]
		[visit-expressions vgenerate-storage-expressions program $ct-reg]
		(storage symbols (@ expr-symbols $program))
		(foreach (l (@ expr-parameters $program)) [prepend (@ expr-symbol $l) symbols $ct-reg])
		[set program [generate-toplevel $program $ct-reg]]
		(storage asms nil)
		[visit-expressions vlinearized-expressions program (storage _ asms $ct-reg)]
		(++[set asms [reverse $asms $ct-reg]])
		[write-str (stdout) (" Checksum)]
		[write-uint (stdout) [length $asms]])
	(handler (continuation _ (code arg0 arg1 arg2 arg3) (begin
		(switch = $code
			(multiple-definition-error [write-str (stdout) (" Multiple definition error.)])
			(param-count-mismatch-error [write-str (stdout) (" Parameter count mismatch error.)])
			(begin))
		[exit #1])))))

(let (fd [open (" test.l2)])
	(let (src-sz [size $fd]) (r [create-buffer #0])
		(let (src-buf [buffer-alloc $r $src-sz]) (expressions nil) (pos #0) (begin
			[read $fd $src-buf $src-sz]
			[close $fd]
			(while [after-leading-space $src-buf $src-sz pos]
				[append [build-expression [build-fragment $src-buf $src-sz pos $r (null)] $r (null)] expressions $r])
			[load-expressions [make-program $expressions $r] nil nil $r]))))

