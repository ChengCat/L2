(function defined-str= (a b) (and $a $b [str= $a $b]))

(function named-ref= (a b) [defined-str= (@expr-name $a) (@expr-name $b)])

(storage multiple-definition-error &0)

(function vfind-multiple-definitions (e handler) (with return
	(switch = (@expr-type $e)
		((-begin-) (let (temp-reg [create-region &0]) (begin
			(let (definitions [filter (function _ (f) (or [= (@expr-type $f) (-storage-)] [= (@expr-type $f) (-function-)]))
					(@expr-expressions $e) $temp-reg])
				(until (partial $definitions) [nil? $partial] [@cdr $partial]
					(if [find (function _ (f ctx) [named-ref= (@expr-reference $f) (@expr-reference $ctx)])
							[cdr $partial] [@car $partial]]
						{$handler multiple-definition-error (@expr-name(@expr-reference[@car $partial]))}
						(begin))))
			[destroy-region $temp-reg]
			{return $e})))
		
		((-continuation-) (-function-) (let (temp-reg [create-region &0]) (begin
			(let (ref-with-params [lst (@expr-reference $e) (@expr-parameters $e) $temp-reg])
				(until (partial $ref-with-params) [nil? $partial] [@cdr $partial]
					(if [find (function _ (f ctx) [named-ref= $f $ctx]) [cdr $partial] [@car $partial]]
						{$handler multiple-definition-error (@expr-name[@car $partial])}
						(begin))))
			[destroy-region $temp-reg]
			{return $e})))
		
		{return $e})))

(function get-parent-function (n) (with return
	{(continuation loop (n)
		(if [= (@expr-type $n) (-function-)]
			{return $n}
			{loop (@expr-parent $n)})) (@expr-parent $n)}))

(function symbol-of (reference) (with return (begin
	(let (same-func (true))
		(until (t $reference) [= $t (null)] (@expr-parent $t)
			(switch = (@expr-type $t)
				((-begin-) (foreach (u (@expr-expressions $t))
					(if (and (or [= (@expr-type $u) (-function-)] (and [= (@expr-type $u) (-storage-)] (or $same-func
							[= (@sym-type(@expr-symbol(@expr-reference $u))) (-static-storage-)])))
							[named-ref= (@expr-reference $u) $reference])
						{return (@expr-symbol(@expr-reference $u))}
						(begin))))
				
				((-function-) (begin
					(if [named-ref= (@expr-reference $t) $reference]
						{return (@expr-symbol(@expr-reference $t))}
						(foreach (u (@expr-parameters $t))
							(if (and (or $same-func [= (@sym-type(@expr-symbol $u)) (-static-storage-)]) [named-ref= $u $reference])
								{return (@expr-symbol $u)}
								(begin))))
					[set same-func (false)]))
				
				((-continuation-) (-with-) (-storage-)
					(if (and (or $same-func [= (@sym-type(@expr-symbol(@expr-reference $t))) (-static-storage-)])
							[named-ref= (@expr-reference $t) $reference])
						{return (@expr-symbol(@expr-reference $t))}
					(if (not [= (@expr-type $t) (-storage-)])
						(foreach (u (@expr-parameters $t))
							(if (and (or $same-func [= (@sym-type(@expr-symbol $u)) (-static-storage-)]) [named-ref= $u $reference])
								{return (@expr-symbol $u)}
								(begin))))))
				
				(begin))))
	{return (null)})))

(function jump-reference? (s) (and [= (@expr-type(@expr-parent $s)) (-jump-)] [= (@expr-reference(@expr-parent $s)) $s]))

(function invoke-reference? (s) (and [= (@expr-type(@expr-parent $s)) (-invoke-)] [= (@expr-reference(@expr-parent $s)) $s]))

(function function-reference? (s) (and [= (@expr-type(@expr-parent $s)) (-function-)] [= (@expr-reference(@expr-parent $s)) $s]))

(function c-reference? (s)
	(and (or [= (@expr-type(@expr-parent $s)) (-continuation-)] [= (@expr-type(@expr-parent $s)) (-with-)])
		[= (@expr-reference(@expr-parent $s)) $s]))

(function get-target-expression (s) (@expr-parent(@sym-definition(@expr-symbol $s))))

(function get-root-function (s) (with return
	{(continuation loop (s parent)
		(if $parent
			{loop $parent (@expr-parent $parent)}
			{return $s})) $s (@expr-parent $s)}))

(storage param-count-mismatch-error &0)

(function vlink-references (s ctx)
	(let (handler ($(loc $ctx &0(unit)))) (r ($(loc $ctx &1(unit))))
		(if [= (@expr-type $s) (-reference-)]
			(with return (begin
				(expr-symbol! $s (if (@expr-symbol $s) (@expr-symbol $s) [symbol-of $s]))
				(if (not (@expr-symbol $s))
					(let (ref [make-reference (@expr-name $s) $r]) (rf [get-root-function $s])
						(let (sym [make-symbol (-static-storage-) (-global-scope-) (-undefined-state-) (@expr-name $s) $ref $r]) (begin
							(expr-symbol! $ref $sym)
							(expr-parameters! $rf [cons $ref (@expr-parameters $rf) $r])
							(expr-parent! $ref $rf)
							(expr-symbol! $s $sym)
							{return $s})))
				(if (and (or (and [jump-reference? $s] [c-reference? (@sym-definition(@expr-symbol $s))])
						(and [invoke-reference? $s] [function-reference? (@sym-definition(@expr-symbol $s))]))
						(not [= [length(@expr-arguments(@expr-parent $s))] [length(@expr-parameters[get-target-expression $s])]]))
					{$handler param-count-mismatch-error (@expr-parent $s) [get-target-expression $s]}
					(begin)))))
		(if (and (or (and [= (@expr-type $s) (-continuation-)] [jump-reference? $s])
				(and [= (@expr-type $s) (-function-)] [invoke-reference? $s]))
				(not [= [length (@expr-arguments(@expr-parent $s))] [length (@expr-parameters $s)]]))
			{$handler param-count-mismatch-error (@expr-parent $s) $s}
			(begin)))))

(function vescape-analysis-aux (ref target)
	(if [jump-reference? $ref]
		(expr-short-circuit! (@expr-parent $ref) $target)
		(expr-escapes! $target (true))))

(function vescape-analysis (s ctx) (with return (begin
	(if (and [= (@expr-type $s) (-reference-)] (not [= (@sym-definition(@expr-symbol $s)) $s])
			[c-reference? (@sym-definition(@expr-symbol $s))])
		[vescape-analysis-aux $s [get-target-expression $s]]
		[vescape-analysis-aux $s $s])
	{return $s})))

(function visit-expressions (visitor s ctx) (begin
	(switch = (@expr-type $$s)
		((-begin-)
			(until (partial (@expr-expressions $$s)) [nil? $partial] [@cdr $partial]
				[visit-expressions $visitor [car $partial] $ctx]))
		
		((-if-) (begin
			[visit-expressions $visitor (expr-condition $$s) $ctx]
			[visit-expressions $visitor (expr-consequent $$s) $ctx]
			[visit-expressions $visitor (expr-alternate $$s) $ctx]))
		
		((-function-) (-continuation-) (-with-)
			[visit-expressions $visitor (expr-expression $$s) $ctx])
		
		((-jump-) (-invoke-) (-storage-) (begin
			(if [= (@expr-type $$s) (-storage-)] (begin) [visit-expressions $visitor (expr-reference $$s) $ctx])
			(until (partial (@expr-arguments $$s)) [nil? $partial] [@cdr $partial]
				[visit-expressions $visitor [car $partial] $ctx])))
		
		(begin))
	(let (parent (@expr-parent $$s)) (begin
		[set $s [$visitor $$s $ctx]]
		(expr-parent! $$s $parent)))))

(function load-expressions (program ectx st-binds ct-reg) (do-let
		[visit-expressions vfind-multiple-definitions program $handler]
	(handler (continuation _ (code arg0 arg1 arg2 arg3) (begin
		(switch = $code
			(multiple-definition-error [write-str (stdout) (" Multiple definition error.)])
			(begin))
		[exit &1])))))

(let (fd [open (" test.l2)])
	(let (src-sz [size $fd]) (r [create-region &0])
		(let (src-buf [region-alloc $r $src-sz]) (expressions nil) (pos &0) (begin
			[read $fd $src-buf $src-sz]
			[close $fd]
			(while [after-leading-space $src-buf $src-sz pos]
				[append [build-expression [build-fragment $src-buf $src-sz pos $r (null)] $r (null)] expressions $r])
			[load-expressions [make-program $expressions $r] nil nil $r]))))

