(function false (l r) (` &0 $r))

(function true (l r) (` &1 $r))

(function lor (l r) (with return
	{(continuation loop (l sexpr)
			(if [nil? $l]
				{return $sexpr}
				{loop [rst $l] (`(let (lor:temp (,[fst $l])) (if $lor:temp $lor:temp (, $sexpr $r)))$r)}))
		[meta:reverse $l $r] (`(false)$r)}))

(function land (l r) (with return
	{(continuation loop (l sexpr)
			(if [nil? $l]
				{return $sexpr}
				{loop [rst $l] (`(let (land:temp (,[fst $l])) (if $land:temp (, $sexpr $r) $land:temp))$r)}))
		[meta:reverse $l $r] (`(true)$r)}))

(function lnot (l r) (`(if (,[fst $l]) &0 &1)$r))

(function meta:reverse (l r)
	(with return
		{(continuation _ (l reversed)
			(if [emt? $l]
				{return $reversed}
				{_ [rst $l] [lst [fst $l] $reversed $r]})) $l [emt $r]}))

(function meta:map (l ctx mapper r)
	(with return
		{(continuation aux (in out)
			(if [emt? $in]
				{return [meta:reverse $out $r]}
				{aux [rst $in] [lst [$mapper [fst $in] $ctx] $out $r]})) $l [emt $r]}))

(++ The following function implements variable binding by do the following
	transformation:
	
	(let (params args) ... expr0)
	->
	(with return
		{(continuation templet0 (params ...)
			{return expr0}) vals ...}))

(function let (l r)
	(`(with let:return
		(,[llst (` jump $r) (`(continuation let:aux
			(,[meta:map [rst [meta:reverse $l $r]] (null) fst $r])
			{let:return (,[fst [meta:reverse $l $r]])}) $r) [meta:map [rst [meta:reverse $l $r]] (null) frst $r] $r])) $r))

(function do-let (l r) [let [meta:reverse $l $r]$r])

(++ The following function implements the switch expression by doing the
	following transformation:
	
	(switch eq0 val0 (vals exprs) ... expr0)
	->
	(let (tempeq0 eq0) (tempval0 val0)
		(if [[' tempeq0] [' tempval0] vals1]
			exprs1
			(if [[' tempeq0] [' tempval0] vals2]
				exprs2
				...
					(if [[' tempeq0] [' tempval0] valsN]
						exprsN
						expr0)))))

(function switch (l r)
	(`(let (switch:= (,[fst $l])) (switch:val (,[frst $l]))
		(,(with return
			{(continuation aux (remaining else-clause)
				(if [emt? $remaining]
					{return $else-clause}
					{aux [rst $remaining]
						(`(if (,[llllst (` invoke $r) (` $switch:= $r) (` $switch:val $r) [ffst $remaining] [emt $r] $r])
							(,[frfst $remaining]) ,$else-clause) $r)}))
				[rst [meta:reverse [rrst $l] $r]] [fst [meta:reverse $l $r]]})))$r))

(function while (l r)
	(`(with while:return {(continuation while:aux (while:val)
		(if (,[fst $l]) {while:aux (,[frst $l])} {while:return $while:val})) (begin)})$r))

(function do-while (l r)
	(`(with do-while:return {(continuation do-while:aux (do-while:val)
			(if (,[frst $l]) {do-while:aux (,[fst $l])} {do-while:return $do-while:val}))
		(,[fst $l])})$r))

(function array (l)
	(if [emt? [rrst $l]]
		(`(with return [allocate [* (,[fst $l]) (,[frst $l])] return]))
		(`(with return [allocate [* (,[fst $l]) [words]]
			(continuation cont (arg)
				(begin
				(for (i &0 (,[fst $l])) [set (loc $arg $i [words]) (,[array [rst $l]])])
				{return $arg}))]))))

(function for (l r)
	(`(with for:return {(continuation for:aux ((,[ffst $l]))
		(if [= ($(,[ffst $l])) (,[frrfst $l])]
			{for:return (begin)}
			(begin (,[frst $l]) {for:aux [+ ($(,[ffst $l])) &1]}))) (,[frfst $l])})$r))
