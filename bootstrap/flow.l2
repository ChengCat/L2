(function false (l r) (` #0 $r))

(function true (l r) (` #1 $r))

(function or (l r) (with return
	{(continuation loop (l sexpr)
			(if [emt? $l]
				{return $sexpr}
				{loop [@rst $l] (`(let (or:temp (,[@fst $l])) (if $or:temp $or:temp (, $sexpr $r)))$r)}))
		[meta:reverse $l $r] (`(false)$r)}))

(function and (l r) (with return
	{(continuation loop (l sexpr)
			(if [emt? $l]
				{return $sexpr}
				{loop [@rst $l] (`(let (and:temp (,[@fst $l])) (if $and:temp (, $sexpr $r) $and:temp))$r)}))
		[meta:reverse $l $r] (`(true)$r)}))

(function not (l r) (`(if (,[@fst $l]) #0 #1)$r))

(function meta:reverse (l r)
	(with return
		{(continuation _ (l reversed)
			(if [emt? $l]
				{return $reversed}
				{_ [@rst $l] [lst [@fst $l] $reversed $r]})) $l emt}))

(function meta:map (l ctx mapper r)
	(with return
		{(continuation aux (in out)
			(if [emt? $in]
				{return [meta:reverse $out $r]}
				{aux [@rst $in] [lst [$mapper [@fst $in] $ctx] $out $r]})) $l emt}))

(++ The following function implements variable binding by do the following
	transformation:
	
	(let (params args) ... expr0)
	->
	(with return
		{(continuation templet0 (params ...)
			{return expr0}) vals ...}))

(function let (l r)
	(`(with let:return
		(,[llst (` jump $r) (`(continuation let:aux
			(,[meta:map [@rst [meta:reverse $l $r]] (null) @fst $r])
			{let:return (,[@fst [meta:reverse $l $r]])}) $r) [meta:map [@rst [meta:reverse $l $r]] (null) @frst $r] $r])) $r))

(function do-let (l r) [let [meta:reverse $l $r]$r])

(++ The following function implements the switch expression by doing the
	following transformation:
	
	(switch eq0 val0 (vals exprs) ... expr0)
	->
	(let (tempeq0 eq0) (tempval0 val0)
		(if [[' tempeq0] [' tempval0] vals1]
			exprs1
			(if [[' tempeq0] [' tempval0] vals2]
				exprs2
				...
					(if [[' tempeq0] [' tempval0] valsN]
						exprsN
						expr0)))))

(function switch (l r)
	(`(let (switch:= (,[@fst $l])) (switch:val (,[@frst $l]))
		(,(with return
			{(continuation aux (remaining else-clause)
				(if [emt? $remaining]
					{return $else-clause}
					{aux [@rst $remaining]
						(`(if (,[lst (` or $r) [meta:map [@rst [meta:reverse [@fst $remaining] $r]] $r
								(function _ (e r) [llllst (` invoke $r) (` $switch:= $r) (` $switch:val $r) $e emt $r]) $r] $r])
							(,[@fst [meta:reverse [@fst $remaining] $r]]) ,$else-clause) $r)}))
				[@rst [meta:reverse [@rrst $l] $r]] [@fst [meta:reverse $l $r]]})))$r))

(function while (l r)
	(`(with while:return {(continuation while:aux (while:val)
		(if (,[@fst $l]) {while:aux (,[@frst $l])} {while:return $while:val})) (begin)})$r))

(function do-while (l r)
	(`(with do-while:return {(continuation do-while:aux (do-while:val)
			(if (,[@frst $l]) {do-while:aux (,[@fst $l])} {do-while:return $do-while:val}))
		(,[@fst $l])})$r))

(function until (l r)
	(`(with until:return {(continuation until:aux ((,[@ffst $l]))
		(if (,[@frst $l])
			{until:return (begin)}
			(begin (,[@frrrst $l]) {until:aux (,[@frrst $l])}))) (,[@frfst $l])})$r))

(++ (fallthrough expr (labels exprs) ...)
	->
	(begin (with labelN ... (begin (with label0
		expr) expr0) ... ) exprN))

(function fallthrough (l r) (with return
	{(continuation loop (acc exprs)
			(if [emt? $exprs]
				{return $acc}
				{loop (`(begin (with (,[@ffst $exprs]) ,$acc) (,[@frfst $exprs]))$r) [@rst $exprs]}))
		[@fst $l] [@rst $l]}))

(function set-storage (l r)
	(`(let (set-storage:target (,[@fst $l]))
		(,[lst (` begin $r) (with return {(continuation loop (exprs offset acc)
				(if [emt? $exprs]
					{return $acc}
					{loop [@rst $exprs] [+ $offset (unit)]
						[lst (`[set [+ $set-storage:target (,[value->literal $offset $r])] (,[@fst $exprs])]$r) $acc $r]}))
			[@rst $l] #0 emt}) $r]))$r))

(storage mytest (" mytest0) (" mytest1) (" mytest2))
[write-str (stdout) ($(loc mytest #0(unit)))]
[write-str (stdout) ($(loc mytest #1(unit)))]
[write-str (stdout) ($(loc mytest #2(unit)))]
(set-storage mytest (" mytest3) (" mytest4) (" mytest5))
[write-str (stdout) ($(loc mytest #0(unit)))]
[write-str (stdout) ($(loc mytest #1(unit)))]
[write-str (stdout) ($(loc mytest #2(unit)))]

(fallthrough
		(begin [write-str (stdout) (" Hello)] {label2 (begin)})
	(label1 [write-str (stdout) (" Label1)])
	(label2 (begin [write-str (stdout) (" Label2)] {label4 (begin)}))
	(label3 [write-str (stdout) (" Label3)])
	(label4 [write-str (stdout) (" Label4)])
	(label5 [write-str (stdout) (" Label5)])
	(label6 [write-str (stdout) (" Label6)]))

[write-str (stdout) (" (lf))]
