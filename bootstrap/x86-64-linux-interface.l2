(function sys-read (l r) [mk# $l $r #0])
(function sys-write (l r) [mk# $l $r #1])
(function sys-open (l r) [mk# $l $r #2])
(function sys-close (l r) [mk# $l $r #3])
(function sys-fstat (l r) [mk# $l $r #5])
(function sys-mmap (l r) [mk# $l $r #9])
(function sys-munmap (l r) [mk# $l $r #11])
(function sys-exit (l r) [mk# $l $r #60])
(function sys-clock-gettime (l r) [mk# $l $r #228])
(function o-rdonly (l r) [mk# $l $r #0])
(function o-rdwr (l r) [mk# $l $r #2])
(function o-creat (l r) [mk# $l $r #64])
(function s-irwxu (l r) [mk# $l $r #448])
(function s-irwxg (l r) [mk# $l $r #56])
(function s-irwxo (l r) [mk# $l $r #7])
(function prot-read (l r) [mk# $l $r #1])
(function prot-write (l r) [mk# $l $r #2])
(function prot-exec (l r) [mk# $l $r #4])
(function prot-none (l r) [mk# $l $r #0])
(function map-private (l r) [mk# $l $r #2])
(function map-anonymous (l r) [mk# $l $r #32])
(function page-size (l r) [mk# $l $r #4096])
(function arg-max (l r) (`(page-size)$r))
(function clock-process-cputime-id (l r) [mk# $l $r #2])
(function stdin (l r) [mk# $l $r #0])
(function stdout (l r) [mk# $l $r #1])
(function null (l r) [mk# $l $r #0])
(function byte (l r) [mk# $l $r #1])
(function unit (l r) [mk# $l $r #8])
(function alloc-alignment (l r) [mk# $l $r #8])

(function exit (code) [syscall (sys-exit) $code])

(function strlen (str) (with return
	{(continuation loop (i)
		(if [getb [+ $str $i]]
			{loop [+ $i #1]}
			{return $i})) #0}))

(function strrchr (s c) (with return
	(let (t [+ $s [strlen $s]]) (begin
		{(continuation loop (t)
			(if [= [getb $t] [getb c]]
				{return $t}
			(if [= $t $s]
				{return (null)}
				{loop [- $t #1]}))) $t}))))

(function strcmp (s1 s2) (with return
	{(continuation loop (s1 s2)
		(if (and [getb $s1] [getb $s2] [= [getb $s1] [getb $s2]])
			{loop [+ $s1 #1] [+ $s2 #1]}
			{return [- [getb $s1] [getb $s2]]})) $s1 $s2}))

(function str= (s1 s2) (not [strcmp $s1 $s2]))

(function strcpy (dest src) (with return
	{(continuation loop (dest src) (begin
		[setb $dest [getb $src]]
		(if [getb $dest]
			{loop [+ $dest #1] [+ $src #1]}
			{return (begin)}))) $dest $src}))

(function memcpy (dest src n) (with return
	{(continuation loop (dest src n)
		(if $n
			(begin
				[setb $dest [getb $src]]
				{loop [+ $dest #1] [+ $src #1] [- $n #1]})
			{return (begin)})) $dest $src $n}))

(function memset (s c n) (with return
	{(continuation loop (s n)
		(if $n
			(begin
				[setb $s [getb c]]
				{loop [+ $s #1] [- $n #1]})
			{return (begin)})) $s $n}))

(function set+ (r inc) [set $r [+ $$r $inc]])

(function isspace (c) (switch = [getb c]
	((space) (true))
	((ff) (true))
	((lf) (true))
	((cr) (true))
	((ht) (true))
	((vt) (true))
	(false)))

(function open (path) [syscall (sys-open) $path [lor (o-rdonly) (o-creat)] [lor (s-irwxu) [lor (s-irwxg) (s-irwxo)]]])

(function write (fd d len) [syscall (sys-write) $fd $d $len])

(function write-str (fd str) [write $fd $str [strlen $str]])

(function write-char (fd ch) [write $fd ch #1])

(function write-uint (fd i) (with return
	[allocate #20 (continuation _ (str) (let (j #19) (begin
		(until (i $i) [= $i #0] [/ $i #10] (begin
			[setb [+ $str $j] (switch = [rem $i #10]
				(#9 (char 9))
				(#8 (char 8))
				(#7 (char 7))
				(#6 (char 6))
				(#5 (char 5))
				(#4 (char 4))
				(#3 (char 3))
				(#2 (char 2))
				(#1 (char 1))
				(char 0))]
			[set j [- $j #1]]))
		[write $fd [+ $str [+ $j #1]] [- #19 $j]]
		{return (begin)})))]))

(function read (fd buf cnt) [syscall (sys-read) $fd $buf $cnt])

(function close (fd) [syscall (sys-close) $fd])

(function size (fd) (with return
	[allocate #144 (continuation _ (statbuf) (begin
		[syscall (sys-fstat) $fd $statbuf]
		{return [get [+ $statbuf #48]]}))]))

(++ Creates a new virtual address mapping of the size in bytes given at len.)

(function mmap (len) [syscall (sys-mmap) (null) $len [lor (prot-read) (prot-write)] [lor (map-private) (map-anonymous)] [lnot #0] #0])

(++ Deletes virtual address mappings coinciding with the range starting with the
	value at ptr and having an extent of the value given at len.)

(function munmap (ptr len) [syscall (sys-munmap) $ptr $len])

(function pad-size (x nearest) (let (r [rem $x $nearest]) [+ $x (if $r [- $nearest $r] #0)]))

(++ A macro to produce the address of an element of a multi-dimensional array.
	For example, (loc $arr #2 #5 #4(unit)) gets the address at offset 2 units
	from $arr, and then gets the address at offset 5 units from that, and then
	gets the address at offset 4 units from that.)

(function loc (l r)
	(if [emt? [@rrrst $l]]
		(`[+ (,[@fst $l]) [* (,[@frst $l]) (,[@frrst $l])]]$r)
		[loc [lst (`($[+ (,[@fst $l]) [*(,[@frst $l])(unit)]])$r) [@rrst $l] $r] $r]))

(++ Creates a new region with a minimum capacity in bytes given by the value at
	min-capacity.)

(function create-buffer (min-capacity) (with return
	(let (len [pad-size [+ $min-capacity [* #5(unit)]] (page-size)])
		(let (reg [mmap $len]) (begin
			[set (loc $reg #0(unit)) (null)]
			[set (loc $reg #1(unit)) $reg]
			[set (loc $reg #2(unit)) [+ $reg [* #5(unit)]]]
			[set (loc $reg #3(unit)) [+ $reg $len]]
			[set (loc $reg #4(unit)) (hex DEADBEEFDEADBEEF)]
			{return $reg})))))

(function check-buffer-integrity (reg)
	(do-while (begin
			(if [= ($(loc $reg #4(unit))) (hex DEADBEEFDEADBEEF)] (begin) [exit #11])
			[set reg ($(loc $reg #0(unit)))])
		$reg))
		

(++ Allocates memory in the region at reg of an amount in bytes equal to the
	integer at len. The only way to deallocate this memory is destroy the entire
	region at reg.)

(function buffer-alloc (reg len) (with return (begin
	(++[check-buffer-integrity $reg])
	[set len [pad-size $len (alloc-alignment)]]
	(if [> [+($(loc $reg #1 #2(unit)))$len] ($(loc $reg #1 #3(unit)))]
		(begin
			[set (loc $reg #1 #0(unit)) [create-buffer [+ $len [* #2[-($(loc $reg #1 #3(unit)))($(loc $reg #1(unit)))]]]]]
			[set (loc $reg #1(unit)) ($(loc $reg #1 #0(unit)))])
		(begin))
	[set (loc $reg #1 #2(unit)) [+($(loc $reg #1 #2(unit)))$len]]
	{return [-($(loc $reg #1 #2(unit)))$len]})))

(++ Releases the memory associated with the region reg. After a call to this
	function, it is invalid to read or write data to the memory allocated on
	this region.)

(function destroy-buffer (reg) (begin
	(++[check-buffer-integrity $reg])
	(do-while
			(let (next-reg ($(loc $reg #0(unit)))) (begin
				[munmap $reg [- ($(loc $reg #3(unit))) $reg]]
				[set reg $next-reg]))
		$reg)))

(++ Returns a C-string that is a copy of the one at src. The returned string and
	its dependencies will all reside in the region reg.)

(function rstrcpy (src reg) (with return
	(let (dest [buffer-alloc $reg [+[strlen $src]#1]]) (begin
		[strcpy $dest $src]
		{return $dest}))))

(++ Returns a list containing the the command line arguments. The returned list
	and its dependencies will all reside in the region reg.)

(function argv (reg) (with return
	(let (f [open (" /proc/self/cmdline)]) (buf [buffer-alloc $reg (arg-max)])
		(let (bytes-rem [read $f $buf (arg-max)]) (begin
			[close $f]
			{(continuation loop (buf bytes-rem args)
				(if $bytes-rem
					{loop [+ $buf [+ [strlen $buf] #1]] [- $bytes-rem [+ [strlen $buf] #1]] [cons $buf $args $reg]}
					{return [reverse $args $reg]})) $buf $bytes-rem nil})))))
