(function char-init (s r) (`(storage _ (null) (char (,[@fst $s])))$r))

(function character-struct (l r) (`[* #2(unit)]$r))

(function cs-list-flag (l r) [mk-field $l $r #0 #8])

(function cs-character (l r) [mk-field $l $r #8 #8])

(function sexpr-struct (l r) (`[* #2(unit)]$r))

(function i/f:char= (a b) [= (@ cs-character $a) (@ cs-character $b)])

(storage characters
	#0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 (char-init !) (char-init ")
	(char-init #) (char-init $) (char-init %) (char-init &) (char-init ') #0 #0 (char-init *) (char-init +) (char-init ,)
	(char-init -) (char-init .) (char-init /) (char-init 0) (char-init 1) (char-init 2) (char-init 3) (char-init 4) (char-init 5)
	(char-init 6) (char-init 7) (char-init 8) (char-init 9) (char-init :) (char-init ;) (char-init <) (char-init =) (char-init >)
	(char-init ?) (char-init @) (char-init A) (char-init B) (char-init C) (char-init D) (char-init E) (char-init F) (char-init G)
	(char-init H) (char-init I) (char-init J) (char-init K) (char-init L) (char-init M) (char-init N) (char-init O) (char-init P)
	(char-init Q) (char-init R) (char-init S) (char-init T) (char-init U) (char-init V) (char-init W) (char-init X) (char-init Y)
	(char-init Z) #0 (char-init \) #0 (char-init ^) (char-init _) (char-init `) (char-init a) (char-init b) (char-init c)
	(char-init d) (char-init e) (char-init f) (char-init g) (char-init h) (char-init i) (char-init j) (char-init k) (char-init l)
	(char-init m) (char-init n) (char-init o) (char-init p) (char-init q) (char-init r) (char-init s) (char-init t) (char-init u)
	(char-init v) (char-init w) (char-init x) (char-init y) (char-init z) #0 (char-init |) #0 (char-init ~) #0)

(function sym-char (s r) (`($(loc characters (,[@fst $s]) (unit)))$r))

(function build-symbol (str r) (with return
	(let (sexprs nil) (begin
		(while [getb $str] (begin
			[append (sym-char [getb $str]) sexprs $r]
			[set str [+ $str #1]]))
		{return $sexprs}))))

(function after-leading-space (l2src l2src-sz pos) (with return
	{(continuation loop ()
		(if (and [< $$pos $l2src-sz] [isspace [getb[+ $l2src $$pos]]])
			(begin [set $pos [+ $$pos #1]] {loop})
			{return [- $l2src-sz $$pos]}))}))

(function build-sigilled-symbol (sigil l2src l2src-sz pos r handler err) (with return (begin
	(if [= $l2src-sz $$pos] {return [build-symbol $sigil $r]} (begin))
	(let (d [getb [+ $l2src $$pos]])
		(if (or [isspace $d] [= $d (rparen)] [= $d (rbrace)] [= $d (rbracket)] [= $d (lparen)] [= $d (lbrace)] [= $d (lbracket)])
			{return [build-symbol $sigil $r]}
			(let (sexprs nil) (begin
				[append [build-symbol $sigil $r] sexprs $r]
				[append [build-fragment $l2src $l2src-sz $pos $r $handler $err] sexprs $r]
				{return $sexprs})))))))

(function build-fragment-list (primitive delimeter l2src l2src-sz pos r handler err) (with return
	(let (sexprs nil) (begin
		[append [build-symbol $primitive $r] sexprs $r]
		(while (true) (begin
			(let (rem [after-leading-space $l2src $l2src-sz $pos])
				(if (and $rem [= [getb [+ $l2src $$pos]] $delimeter])
					(begin [set $pos [+ $$pos #1]] {return $sexprs})
					(begin)))
			[append [build-fragment $l2src $l2src-sz $pos $r $handler $err] sexprs $r]))
		{return $sexprs}))))

(storage unexpected-char-error #0)

(function build-fragment (l2src l2src-sz pos r handler err) (with return
	(if [= $l2src-sz $$pos]
		{$handler (set-storage $err unexpected-char-error #0 $$pos)}
		(let (c [getb [+ $l2src $$pos]])
			(if (or [isspace $c] [= $c (rparen)] [= $c (rbrace)] [= $c (rbracket)])
				{$handler (set-storage $err unexpected-char-error $c $$pos)}
				(begin
					[set $pos [+ $$pos #1]]
					{return (switch = $c
						((lparen) [@cdr [build-fragment-list (" expression) (rparen) $l2src $l2src-sz $pos $r $handler $err]])
						((lbrace) [build-fragment-list (" jump) (rbrace) $l2src $l2src-sz $pos $r $handler $err])
						((lbracket) [build-fragment-list (" invoke) (rbracket) $l2src $l2src-sz $pos $r $handler $err])
						((char $) [build-sigilled-symbol (" $) $l2src $l2src-sz $pos $r $handler $err])
						((char #) [build-sigilled-symbol (" #) $l2src $l2src-sz $pos $r $handler $err])
						((char ,) [build-sigilled-symbol (" ,) $l2src $l2src-sz $pos $r $handler $err])
						((char `) [build-sigilled-symbol (" `) $l2src $l2src-sz $pos $r $handler $err])
						(let (l nil) (begin
							(do-while (begin
									[append (sym-char $c) l $r]
									(if [= $$pos $l2src-sz] {return $l} (begin))
									[set c [getb [+ $l2src $$pos]]]
									[set $pos [+ $$pos #1]])
								(not (or [isspace $c] [= $c (lparen)] [= $c (rparen)] [= $c (lbrace)] [= $c (rbrace)]
									[= $c (lbracket)] [= $c (rbracket)])))
							[set $pos [- $$pos #1]]
							{return $l})))}))))))

(function i/f:symbol? (d) (and [length $d] (not (@ cs-list-flag[@car $d]))))

(function to-string (d r) (with return
	(let (str [buffer-alloc $r [+ [length $d] #1]]) (i #0) (begin
		(foreach (t $d) (begin
			[setb [+ $str $i] (@ cs-character $t)]
			[set i [+ $i #1]]))
		[setb [+ $str $i] (null)]
		{return $str}))))

(function copy-fragment (l r) (with return
	(let (c nil) (begin
		(if [i/f:symbol? $l]
			(foreach (s $l) [append (sym-char (@ cs-character $s)) c $r])
			(foreach (s $l) [append [copy-fragment $s $r] c $r]))
		{return $c}))))

(function print-fragment (d hdl err) (begin
	[print-char (stdout) (lparen) $hdl $err]
	(if [nil? $d] (begin) (begin
		(if [symbol? $d]
			[print-char (stdout) (@ cs-character[@car $d]) $hdl $err]
			[print-fragment [@car $d] $hdl $err])
		[print-str (stdout) ("(space).(space)) $hdl $err]
		[print-fragment [@cdr $d] $hdl $err]))
	[print-char (stdout) (rparen) $hdl $err]))

