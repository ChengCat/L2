(function -storage- (l r p) [mk# $l $r $p #0])
(function -function- (l r p) [mk# $l $r $p #1])
(function -with- (l r p) [mk# $l $r $p #2])
(function -invoke- (l r p) [mk# $l $r $p #3])
(function -if- (l r p) [mk# $l $r $p #4])
(function -begin- (l r p) [mk# $l $r $p #5])
(function -literal- (l r p) [mk# $l $r $p #6])
(function -reference- (l r p) [mk# $l $r $p #7])
(function -jump- (l r p) [mk# $l $r $p #8])
(function -continuation- (l r p) [mk# $l $r $p #9])
(function -assembly- (l r p) [mk# $l $r $p #10])
(function -non-primitive- (l r p) [mk# $l $r $p #11])

(function static-storage (l r p) [mk# $l $r $p #0])
(function dynamic-storage (l r p) [mk# $l $r $p #1])

(function local-scope (l r p) [mk# $l $r $p #0])
(function global-scope (l r p) [mk# $l $r $p #1])

(function undefined-state (l r p) [mk# $l $r $p #0])
(function defined-state (l r p) [mk# $l $r $p #1])

(function symbol (l r p) [mk# $l $r $p #48])

(function sym-name (l r p) [mk-field $l $r $p #0 #8])
(function sym-offset (l r p) [mk-field $l $r $p #8 #8])
(function sym-size (l r p) [mk-field $l $r $p #16 #8])
(function sym-definition (l r p) [mk-field $l $r $p #24 #8])
(function sym-context (l r p) [mk-field $l $r $p #32 #8])
(function sym-type (l r p) [mk-field $l $r $p #40 #1])
(function sym-scope (l r p) [mk-field $l $r $p #41 #1])
(function sym-state (l r p) [mk-field $l $r $p #42 #1])

(function make-symbol (type scope state name definition r) (with return
	(let (sym [buffer-alloc $r (symbol)]) (begin
		(setf sym-type $sym $type)
		(setf sym-scope $sym $scope)
		(setf sym-state $sym $state)
		(setf sym-name $sym $name)
		(setf sym-definition $sym $definition)
		{return $sym}))))

(function expression (l r p) [mk# $l $r $p #72])

(function expr-type (l r p) [mk-field $l $r $p #0 #8])
(function expr-parent (l r p) [mk-field $l $r $p #8 #8])
(function expr-return-symbol (l r p) [mk-field $l $r $p #16 #8])
(++ Only for type(s) (-begin-))
(function expr-expressions (l r p) [mk-field $l $r $p #24 #8])
(++ Only for type(s) (-assembly-))
(function expr-opcode (l r p) [mk-field $l $r $p #24 #8])
(++ Only for type(s) (-assembly-) (-storage-) (-invoke-) (-jump-))
(function expr-arguments (l r p) [mk-field $l $r $p #32 #8])
(++ Only for type(s) (-storage-) (-invoke-) (-jump-) (-function-) (-continuation-) (-with-) (-non-primitive-))
(function expr-reference (l r p) [mk-field $l $r $p #24 #8])
(++ Only for type(s) (-jump-))
(function expr-short-circuit (l r p) [mk-field $l $r $p #40 #8])
(++ Only for type(s) (-if-))
(function expr-condition (l r p) [mk-field $l $r $p #24 #8])
(function expr-consequent (l r p) [mk-field $l $r $p #32 #8])
(function expr-alternate (l r p) [mk-field $l $r $p #40 #8])
(++ Only for type(s) (-literal-))
(function expr-value (l r p) [mk-field $l $r $p #24 #8])
(++ Only for type(s) (-function-) (-continuation-) (-with-))
(function expr-expression (l r p) [mk-field $l $r $p #32 #8])
(function expr-parameters (l r p) [mk-field $l $r $p #40 #8])
(++ Only for type(s) (-function-))
(function expr-symbols (l r p) [mk-field $l $r $p #48 #8])
(function expr-expression-return-symbol (l r p) [mk-field $l $r $p #56 #8])
(++ Only for type(s) (-continuation-) (-with-))
(function expr-cont-instr-ref (l r p) [mk-field $l $r $p #48 #8])
(function expr-escapes (l r p) [mk-field $l $r $p #56 #8])
(++ Only for type(s) (-reference-))
(function expr-name (l r p) [mk-field $l $r $p #24 #8])
(function expr-symbol (l r p) [mk-field $l $r $p #32 #8])
(++ Only for type(s) (-non-primitive-))
(function expr-argument (l r p) [mk-field $l $r $p #32 #8])
(function expr-indirections (l r p) [mk-field $l $r $p #40 #8])
(function expr-st-binds (l r p) [mk-field $l $r $p #48 #8])
(function expr-dyn-refs (l r p) [mk-field $l $r $p #56 #8])
(function expr-dynamic-context (l r p) [mk-field $l $r $p #64 #8])

(function make-literal (value reg) (with return
	(let (t [buffer-alloc $reg (expression)]) (begin
		(setf expr-type $t (-literal-))
		(setf expr-value $t $value)
		{return $t}))))

(function make-reference (name reg) (with return
	(let (ref [buffer-alloc $reg (expression)]) (begin
		(setf expr-type $ref (-reference-))
		(setf expr-name $ref $name)
		(setf expr-symbol $ref (null))
		{return $ref}))))

(function refer-reference (reference referent) (setf expr-symbol $reference (@ $referent expr-symbol)))

(function use-symbol (sym reg) (with return
	(let (ref [buffer-alloc $reg (expression)]) (begin
		(setf expr-type $ref (-reference-))
		(setf expr-name $ref (@ $sym sym-name))
		(setf expr-symbol $ref $sym)
		{return $ref}))))

(function make-begin (expressions reg) (with return
	(let (beg [buffer-alloc $reg (expression)]) (begin
		(setf expr-type $beg (-begin-))
		(setf expr-expressions $beg $expressions)
		(foreach (expr $expressions) (setf expr-parent $expr $beg))
		{return $beg}))))

(function make-function (ref params expr reg) (with return
	(let (func [buffer-alloc $reg (expression)]) (begin
		(setf expr-type $func (-function-))
		(setf expr-reference $func $ref)
		(setf expr-parent $ref $func)
		(setf expr-symbol $ref [make-symbol (static-storage) (local-scope) (defined-state) (@ $ref expr-name) $ref $reg])
		(setf expr-parameters $func $params)
		(foreach (param $params) (begin
			(setf expr-parent $param $func)
			(setf expr-symbol $param [make-symbol (dynamic-storage) (local-scope) (defined-state) (@ $param expr-name) $param $reg])))
		(setf expr-symbols $func nil)
		(setf expr-expression $func $expr)
		(setf expr-parent $expr $func)
		{return $func}))))

(function make-continuation (ref params expr reg) (with return
	(let (cont [buffer-alloc $reg (expression)]) (begin
		(setf expr-type $cont (-continuation-))
		(setf expr-reference $cont $ref)
		(setf expr-parent $ref $cont)
		(setf expr-symbol $ref [make-symbol (dynamic-storage) (local-scope) (defined-state) (@ $ref expr-name) $ref $reg])
		(setf expr-parameters $cont $params)
		(foreach (param $params) (begin
			(setf expr-parent $param $cont)
			(setf expr-symbol $param [make-symbol (dynamic-storage) (local-scope) (defined-state) (@ $param expr-name) $param
				$reg])))
		(setf expr-escapes $cont (true))
		(setf expr-expression $cont $expr)
		(setf expr-parent $expr $cont)
		{return $cont}))))

(function make-with (ref expr reg) (with return
	(let (wth [buffer-alloc $reg (expression)]) (begin
		(setf expr-type $wth (-with-))
		(setf expr-reference $wth $ref)
		(setf expr-parent $ref $wth)
		(setf expr-symbol $ref [make-symbol (dynamic-storage) (local-scope) (defined-state) (@ $ref expr-name) $ref $reg])
		(let (param [make-reference (null) $reg]) (begin
			(setf expr-parent $param $wth)
			(setf expr-symbol $param [make-symbol (dynamic-storage) (local-scope) (defined-state) (@ $param expr-name) $param
				$reg])
			(setf expr-parameters $wth [lst $param nil $reg])))
		(setf expr-escapes $wth (true))
		(setf expr-expression $wth $expr)
		{return $wth}))))

(function make-asm (opcode arguments reg) (with return
	(let (u [buffer-alloc $reg (expression)]) (begin
		(setf expr-type $u (-assembly-))
		(setf expr-opcode $u $opcode)
		(setf expr-arguments $u $arguments)
		(foreach (arg $arguments) (setf expr-parent $arg $u))
		{return $u}))))

(function make-asmN (l r p)
	(use-memo $p (`[make-asm (,[@fst $l]) (,[list [meta:reverse [lst [@frrst $l] [meta:reverse [@frst $l] $r] $r] $r] $r emt])
		(,[@frrst $l])]$r)))

(function make-jump (ref args reg) (with return
	(let (u [buffer-alloc $reg (expression)]) (begin
		(setf expr-type $u (-jump-))
		(setf expr-reference $u $ref)
		(setf expr-parent $ref $u)
		(setf expr-arguments $u $args)
		(foreach (arg $args) (setf expr-parent $arg $u))
		{return $u}))))

(function make-storage (ref args reg) (with return
	(let (u [buffer-alloc $reg (expression)]) (begin
		(setf expr-type $u (-storage-))
		(setf expr-reference $u $ref)
		(setf expr-parent $ref $u)
		(setf expr-symbol $ref [make-symbol (dynamic-storage) (local-scope) (defined-state) (@ $ref expr-name) $ref $reg])
		(setf expr-arguments $u $args)
		(foreach (arg $args) (setf expr-parent $arg $u))
		{return $u}))))

(function make-non-primitive (ref arg reg) (with return
	(let (u [buffer-alloc $reg (expression)]) (begin
		(setf expr-type $u (-non-primitive-))
		(setf expr-reference $u $ref)
		(setf expr-parent $ref $u)
		(setf expr-argument $u $arg)
		(setf expr-indirections $u nil)
		(setf expr-st-binds $u nil)
		(setf expr-dyn-refs $u nil)
		{return $u}))))

(function make-if (condition consequent alternate reg) (with return
	(let (u [buffer-alloc $reg (expression)]) (begin
		(setf expr-type $u (-if-))
		(setf expr-condition $u $condition)
		(setf expr-parent $condition $u)
		(setf expr-consequent $u $consequent)
		(setf expr-parent $consequent $u)
		(setf expr-alternate $u $alternate)
		(setf expr-parent $alternate $u)
		{return $u}))))

(function make-invoke (ref args reg) (with return
	(let (u [buffer-alloc $reg (expression)]) (begin
		(setf expr-type $u (-invoke-))
		(setf expr-reference $u $ref)
		(setf expr-parent $ref $u)
		(setf expr-arguments $u $args)
		(foreach (arg $args) (setf expr-parent $arg $u))
		{return $u}))))

(function make-program (exprs r) (with return
	(let (program [make-function [make-reference (null) $r] nil [make-begin $exprs $r] $r]) (begin
		(setf expr-parent $program (null))
		(foreach (expr $exprs)
			(if (or [= (@ $expr expr-type) (-function-)] [= (@ $expr expr-type) (-storage-)])
				(setf sym-scope (@(@ $expr expr-reference)expr-symbol) (global-scope))
				(begin)))
		{return $program}))))

(function replace-expression (l r p) (use-memo $p
	(`(let (replace-expression:orig (,[@fst $l]))
		(let (replace-expression:parent (@ $$replace-expression:orig expr-parent))
			(let (replace-expression:repl (,[@frst $l])) (begin
				(setf expr-parent $replace-expression:repl $replace-expression:parent)
				[set $replace-expression:orig $replace-expression:repl]))))$r)))

(function print-expression (s)
	(switch = (@ $s expr-type)
		((-begin-) (begin
			[write-str (stdout) (" (lparen)begin(space))]
			(foreach (t (@ $s expr-expressions)) (begin
				[print-expression $t]
				[write-str (stdout) (" (space))]))
			[write-str (stdout) (" (bs)(rparen))]))
		
		((-with-) (begin
			[write-str (stdout) (" (lparen)with(space))]
			[print-expression (@ $s expr-reference)]
			[write-str (stdout) (" (space))]
			[print-expression (@ $s expr-expression)]
			[write-str (stdout) (" (rparen))]))
		
		((-invoke-) (-jump-) (-storage-) (begin
			[write-str (stdout) (switch = (@ $s expr-type)
				((-invoke-) (" (lbracket)))
				((-jump-) (" (lbrace)))
				(" (lparen)storage(space)))]
			[print-expression (@ $s expr-reference)]
			[write-str (stdout) (" (space))]
			(foreach (t (@ $s expr-arguments)) (begin
				[print-expression $t]
				[write-str (stdout) (" (space))]))
			[write-str (stdout) (" (bs))]
			[write-str (stdout) (switch = (@ $s expr-type)
				((-invoke-) (" (rbracket)))
				((-jump-) (" (rbrace)))
				(" (rbracket)))]))
		
		((-function-) (-continuation-) (begin
			[write-str (stdout) (" (lparen))]
			[write-str (stdout) (switch = (@ $s expr-type)
				((-function-) (" function))
				(" continuation))]
			[write-str (stdout) (" (space))]
			[print-expression (@ $s expr-reference)]
			[write-str (stdout) (" (space)(lparen)(space))]
			(foreach (t (@ $s expr-parameters)) (begin
				[print-expression $t]
				[write-str (stdout) (" (space))]))
			[write-str (stdout) (" (rparen)(space))]
			[print-expression (@ $s expr-expression)]
			[write-str (stdout) (" (rparen))]))
			
		((-if-) (begin
			[write-str (stdout) (" (lparen)if(space))]
			[print-expression (@ $s expr-condition)]
			[write-str (stdout) (" (space))]
			[print-expression (@ $s expr-consequent)]
			[write-str (stdout) (" (space))]
			[print-expression (@ $s expr-alternate)]
			[write-str (stdout) (" (rparen))]))
		
		((-reference-)
			(if (@ $s expr-name)
				[write-str (stdout) (@ $s expr-name)]
				(begin
					[write-str (stdout) (" (lparen)reference(space))]
					[write-uint (stdout) (@ $s expr-symbol)]
					[write-str (stdout) (" (rparen))])))
					
		((-literal-) (begin
			[write-str (stdout) (" (lparen)literal(space))]
			[write-uint (stdout) (@ $s expr-value)]
			[write-str (stdout) (" (rparen))]))
		
		((-non-primitive-) (begin
			[write-str (stdout) (" (lparen))]
			[print-expression (@ $s expr-reference)]
			[write-str (stdout) (" (space))]
			[print-fragment (@ $s expr-argument)]
			[write-str (stdout) (" (rparen))]))
			
		(begin)))

(function build-expression-literal-len (l r p) [mk# $l $r $p #64])

(storage special-form-error #0)

(function build-expression (d reg handler)
	(if [= [length $d] #0] {$handler}
	(if [i/f:symbol? $d] [make-reference [to-string $d $reg] $reg]
	(switch str= [to-string [@car $d] $reg]
		((" with)
			(if (not [= [length $d] #3])
				{$handler special-form-error $d (null)}
			(if (not [i/f:symbol? [@cadr $d]])
				{$handler special-form-error $d [@cadr $d]}
				[make-with [build-expression [@cadr $d] $reg $handler] [build-expression [@caddr $d] $reg $handler] $reg])))
		
		((" begin)
			(with return (let (exprs nil) (begin
				(foreach (v [@cdr $d]) [append [build-expression $v $reg $handler] exprs $reg])
				{return [make-begin $exprs $reg]}))))
		
		((" if)
			(if (not [= [length $d] #4])
				{$handler special-form-error $d (null)}
				[make-if [build-expression [@cadr $d] $reg $handler] [build-expression [@caddr $d] $reg $handler]
					[build-expression [@cadddr $d] $reg $handler] $reg]))
		
		((" function) (" continuation)
			(if (not [= [length $d] #4])
				{$handler special-form-error $d (null)}
			(if (not [i/f:symbol? [@cadr $d]])
				{$handler special-form-error $d [@cadr $d]}
			(if [i/f:symbol? [@caddr $d]]
				{$handler special-form-error $d [@caddr $d]}
				(with return (let (parameters nil) (begin
					(foreach (v [@caddr $d])
						(if [i/f:symbol? $v]
							[append [build-expression $v $reg $handler] parameters $reg]
							{$handler special-form-error $d $v}))
					{return [(switch str= [to-string [@car $d] $reg]
							((" function) make-function)
							make-continuation)
						[build-expression [@cadr $d] $reg $handler] $parameters [build-expression [@cadddr $d] $reg $handler]
							$reg]})))))))
		
		((" invoke) (" jump) (" storage)
			(if [= [length $d] #1]
				{$handler special-form-error $d (null)}
			(if (and [str= [to-string [@car $d] $reg] (" storage)] (not [i/f:symbol? [@cadr $d]]))
				{$handler special-form-error $d [@cadr $d]}
				(with return (let (arguments nil) (begin
					(foreach (v [@cddr $d]) [append [build-expression $v $reg $handler] arguments $reg])
					{return [(switch str= [to-string [@car $d] $reg]
							((" invoke) make-invoke)
							((" jump) make-jump)
							make-storage)
						[build-expression [@cadr $d] $reg $handler] $arguments $reg]}))))))
		
		((" literal)
			(if (not [= [length $d] #2])
				{$handler special-form-error $d (null)}
			(if (or (not [i/f:symbol? [@cadr $d]]) (not [= [length [@cadr $d]] (build-expression-literal-len)]))
				{$handler special-form-error $d [@cadr $d]}
				[make-literal (with return
					{(continuation loop (str i value) (begin
							[set value [<< $value #1]]
							(if [= $i #0]
								{return $value}
							(if [= [getb $str] (char 1)]
								{loop [+ $str #1] [- $i #1] [+ $value #1]}
							(if [= [getb $str] (char 0)]
								{loop [+ $str #1] [- $i #1] $value}
								{$handler special-form-error $d [@cadr $d]})))))
						[to-string [@cadr $d] $reg] (build-expression-literal-len) #0}) $reg])))
		
		[make-non-primitive [build-expression [@car $d] $reg $handler] [@cdr $d] $reg]))))

(let (r [create-buffer #0]) [print-expression [make-begin [llst [make-reference (" Hellodude) $r] [make-literal #20 $r] nil $r] $r]])

[write-str (stdout) (" Starting here:(lf))]

(++(let (r [create-buffer #0]) (pos #0)
	(do-let (begin
			[write-str (stdout) (" (lparen)begin(lbrace)lokay(rbrace)a(rparen)o)]
			[print-expression [build-expression
				[build-fragment (" (lparen)with(lbrace)lokay(rbrace)a(rparen)o) #22 pos $r $handler] $r $handler]]
			[build-symbol (" Hello) $r])
		(handler (continuation _ (code arg0 arg1 arg2 arg3) (begin
			[destroy-buffer $r]
			(switch = $code
				(special-form-error [write-str (stdout) (" Okay, it's a special form error(lf))])
				(unexpected-char-error [write-str (stdout) (" It was an unexpected character!(lf))])
				[write-str (stdout) (" We do not know what caused this!(lf))])
			[exit #1]))))))
