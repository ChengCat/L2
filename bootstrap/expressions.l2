(function -storage- (l r p) [mk# $l $r $p #0])
(function -function- (l r p) [mk# $l $r $p #1])
(function -with- (l r p) [mk# $l $r $p #2])
(function -invoke- (l r p) [mk# $l $r $p #3])
(function -if- (l r p) [mk# $l $r $p #4])
(function -begin- (l r p) [mk# $l $r $p #5])
(function -literal- (l r p) [mk# $l $r $p #6])
(function -reference- (l r p) [mk# $l $r $p #7])
(function -jump- (l r p) [mk# $l $r $p #8])
(function -continuation- (l r p) [mk# $l $r $p #9])
(function -assembly- (l r p) [mk# $l $r $p #10])
(function -non-primitive- (l r p) [mk# $l $r $p #11])

(function -static-storage- (l r p) [mk# $l $r $p #0])
(function -dynamic-storage- (l r p) [mk# $l $r $p #1])

(function -local-scope- (l r p) [mk# $l $r $p #0])
(function -global-scope- (l r p) [mk# $l $r $p #1])

(function -undefined-state- (l r p) [mk# $l $r $p #0])
(function -defined-state- (l r p) [mk# $l $r $p #1])

(function symbol (l r p) [mk# $l $r $p #48])

(function sym-name (l r p) [mk-field $l $r $p #0 #8])
(function sym-offset (l r p) [mk-field $l $r $p #8 #8])
(function sym-size (l r p) [mk-field $l $r $p #16 #8])
(function sym-definition (l r p) [mk-field $l $r $p #24 #8])
(function sym-context (l r p) [mk-field $l $r $p #32 #8])
(function sym-type (l r p) [mk-field $l $r $p #40 #1])
(function sym-scope (l r p) [mk-field $l $r $p #41 #1])
(function sym-state (l r p) [mk-field $l $r $p #42 #1])

(function make-symbol (type scope state name definition r) (with return
	(let (sym [region-alloc $r (symbol)]) (begin
		(! $sym sym-type $type)
		(! $sym sym-scope $scope)
		(! $sym sym-state $state)
		(! $sym sym-name $name)
		(! $sym sym-definition $definition)
		{return $sym}))))

(function expression (l r p) [mk# $l $r $p #72])

(function expr-type (l r p) [mk-field $l $r $p #0 #8])
(function expr-parent (l r p) [mk-field $l $r $p #8 #8])
(function expr-return-symbol (l r p) [mk-field $l $r $p #16 #8])
(++ Only for type(s) (-begin-))
(function expr-expressions (l r p) [mk-field $l $r $p #24 #8])
(++ Only for type(s) (-assembly-))
(function expr-opcode (l r p) [mk-field $l $r $p #24 #8])
(++ Only for type(s) (-assembly-) (-storage-) (-invoke-) (-jump-))
(function expr-arguments (l r p) [mk-field $l $r $p #32 #8])
(++ Only for type(s) (-storage-) (-invoke-) (-jump-) (-function-) (-continuation-) (-with-) (-non-primitive-))
(function expr-reference (l r p) [mk-field $l $r $p #24 #8])
(++ Only for type(s) (-jump-))
(function expr-short-circuit (l r p) [mk-field $l $r $p #40 #8])
(++ Only for type(s) (-if-))
(function expr-condition (l r p) [mk-field $l $r $p #24 #8])
(function expr-consequent (l r p) [mk-field $l $r $p #32 #8])
(function expr-alternate (l r p) [mk-field $l $r $p #40 #8])
(++ Only for type(s) (-literal-))
(function expr-value (l r p) [mk-field $l $r $p #24 #8])
(++ Only for type(s) (-function-) (-continuation-) (-with-))
(function expr-expression (l r p) [mk-field $l $r $p #32 #8])
(function expr-parameters (l r p) [mk-field $l $r $p #40 #8])
(++ Only for type(s) (-function-))
(function expr-symbols (l r p) [mk-field $l $r $p #48 #8])
(function expr-expression-return-symbol (l r p) [mk-field $l $r $p #56 #8])
(++ Only for type(s) (-continuation-) (-with-))
(function expr-cont-instr-ref (l r p) [mk-field $l $r $p #48 #8])
(function expr-escapes (l r p) [mk-field $l $r $p #56 #8])
(++ Only for type(s) (-reference-))
(function expr-name (l r p) [mk-field $l $r $p #24 #8])
(function expr-symbol (l r p) [mk-field $l $r $p #32 #8])
(++ Only for type(s) (-non-primitive-))
(function expr-argument (l r p) [mk-field $l $r $p #32 #8])
(function expr-indirections (l r p) [mk-field $l $r $p #40 #8])
(function expr-st-binds (l r p) [mk-field $l $r $p #48 #8])
(function expr-dyn-refs (l r p) [mk-field $l $r $p #56 #8])
(function expr-dynamic-context (l r p) [mk-field $l $r $p #64 #8])

(function make-literal (value reg) (with return
	(let (t [region-alloc $reg (expression)]) (begin
		(! $t expr-type (-literal-))
		(! $t expr-value $value)
		{return $t}))))

(function make-reference (name reg) (with return
	(let (ref [region-alloc $reg (expression)]) (begin
		(! $ref expr-type (-reference-))
		(! $ref expr-name $name)
		(! $ref expr-symbol (null))
		{return $ref}))))

(function refer-reference (reference referent) (! $reference expr-symbol (@ $referent expr-symbol)))

(function use-symbol (sym reg) (with return
	(let (ref [region-alloc $reg (expression)]) (begin
		(! $ref expr-type (-reference-))
		(! $ref expr-name (@ $sym sym-name))
		(! $ref expr-symbol $sym)
		{return $ref}))))

(function make-begin (expressions reg) (with return
	(let (beg [region-alloc $reg (expression)]) (begin
		(! $beg expr-type (-begin-))
		(! $beg expr-expressions $expressions)
		(foreach (expr $expressions) (! $expr expr-parent $beg))
		{return $beg}))))

(function make-function (ref params expr reg) (with return
	(let (func [region-alloc $reg (expression)]) (begin
		(! $func expr-type (-function-))
		(! $func expr-reference $ref)
		(! $ref expr-parent $func)
		(! $ref expr-symbol [make-symbol (-static-storage-) (-local-scope-) (-defined-state-) (@ $ref expr-name) $ref $reg])
		(! $func expr-parameters $params)
		(foreach (param $params) (begin
			(! $param expr-parent $func)
			(! $param expr-symbol [make-symbol (-dynamic-storage-) (-local-scope-) (-defined-state-) (@ $param expr-name) $param $reg])))
		(! $func expr-symbols nil)
		(! $func expr-expression $expr)
		(! $expr expr-parent $func)
		{return $func}))))

(function make-continuation (ref params expr reg) (with return
	(let (cont [region-alloc $reg (expression)]) (begin
		(! $cont expr-type (-continuation-))
		(! $cont expr-reference $ref)
		(! $ref expr-parent $cont)
		(! $ref expr-symbol [make-symbol (-dynamic-storage-) (-local-scope-) (-defined-state-) (@ $ref expr-name) $ref $reg])
		(! $cont expr-parameters $params)
		(foreach (param $params) (begin
			(! $param expr-parent $cont)
			(! $param expr-symbol [make-symbol (-dynamic-storage-) (-local-scope-) (-defined-state-) (@ $param expr-name) $param $reg])))
		(! $cont expr-escapes (true))
		(! $cont expr-expression $expr)
		(! $expr expr-parent $cont)
		{return $cont}))))

(function make-with (ref expr reg) (with return
	(let (wth [region-alloc $reg (expression)]) (begin
		(! $wth expr-type (-with-))
		(! $wth expr-reference $ref)
		(! $ref expr-parent $wth)
		(! $ref expr-symbol [make-symbol (-dynamic-storage-) (-local-scope-) (-defined-state-) (@ $ref expr-name) $ref $reg])
		(let (param [make-reference (null) $reg]) (begin
			(! $param expr-parent $wth)
			(! $param expr-symbol [make-symbol (-dynamic-storage-) (-local-scope-) (-defined-state-) (@ $param expr-name) $param $reg])
			(! $wth expr-parameters [lst $param nil $reg])))
		(! $wth expr-escapes (true))
		(! $wth expr-expression $expr)
		{return $wth}))))

(function make-asm (opcode arguments reg) (with return
	(let (u [region-alloc $reg (expression)]) (begin
		(! $u expr-type (-assembly-))
		(! $u expr-opcode $opcode)
		(! $u expr-arguments $arguments)
		(foreach (arg $arguments) (! $arg expr-parent $u))
		{return $u}))))

(function make-jump (ref args reg) (with return
	(let (u [region-alloc $reg (expression)]) (begin
		(! $u expr-type (-jump-))
		(! $u expr-reference $ref)
		(! $ref expr-parent $u)
		(! $u expr-arguments $args)
		(foreach (arg $args) (! $arg expr-parent $u))
		{return $u}))))

(function make-storage (ref args reg) (with return
	(let (u [region-alloc $reg (expression)]) (begin
		(! $u expr-type (-storage-))
		(! $u expr-reference $ref)
		(! $ref expr-parent $u)
		(! $ref expr-symbol [make-symbol (-dynamic-storage-) (-local-scope-) (-defined-state-) (@ $ref expr-name) $ref $reg])
		(! $u expr-arguments $args)
		(foreach (arg $args) (! $arg expr-parent $u))
		{return $u}))))

(function make-non-primitive (ref arg reg) (with return
	(let (u [region-alloc $reg (expression)]) (begin
		(! $u expr-type (-non-primitive-))
		(! $u expr-reference $ref)
		(! $ref expr-parent $u)
		(! $u expr-argument $arg)
		(! $u expr-indirections nil)
		(! $u expr-st-binds nil)
		(! $u expr-dyn-refs nil)
		{return $u}))))

(function make-if (condition consequent alternate reg) (with return
	(let (u [region-alloc $reg (expression)]) (begin
		(! $u expr-type (-if-))
		(! $u expr-condition $condition)
		(! $condition expr-parent $u)
		(! $u expr-consequent $consequent)
		(! $consequent expr-parent $u)
		(! $u expr-alternate $alternate)
		(! $alternate expr-parent $u)
		{return $u}))))

(function make-invoke (ref args reg) (with return
	(let (u [region-alloc $reg (expression)]) (begin
		(! $u expr-type (-invoke-))
		(! $u expr-reference $ref)
		(! $ref expr-parent $u)
		(! $u expr-arguments $args)
		(foreach (arg $args) (! $arg expr-parent $u))
		{return $u}))))

(function make-program (exprs r) (with return
	(let (program [make-function [make-reference (null) $r] nil [make-begin $exprs $r] $r]) (begin
		(! $program expr-parent (null))
		(foreach (expr $exprs)
			(if (or [= (@ $expr expr-type) (-function-)] [= (@ $expr expr-type) (-storage-)])
				(! (@(@ $expr expr-reference)expr-symbol) sym-scope (-global-scope-))
				(begin)))
		{return $program}))))

(function replace-expression (l r p) (use-memo $p
	(`(let (replace-expression:orig (,[@fst $l]))
		(let (replace-expression:parent (@ $$replace-expression:orig expr-parent))
			(let (replace-expression:repl (,[@frst $l])) (begin
				(! $replace-expression:repl expr-parent $replace-expression:parent)
				[set $replace-expression:orig $replace-expression:repl]))))$r)))

(function print-expression (s)
	(switch = (@ $s expr-type)
		((-begin-) (begin
			[write-str (stdout) (" (lparen)begin(space))]
			(foreach (t (@ $s expr-expressions)) (begin
				[print-expression $t]
				[write-str (stdout) (" (space))]))
			[write-str (stdout) (" (bs)(rparen))]))
		
		((-with-) (begin
			[write-str (stdout) (" (lparen)with(space))]
			[print-expression (@ $s expr-reference)]
			[write-str (stdout) (" (space))]
			[print-expression (@ $s expr-expression)]
			[write-str (stdout) (" (rparen))]))
		
		((-invoke-) (-jump-) (-storage-) (begin
			[write-str (stdout) (switch = (@ $s expr-type)
				((-invoke-) (" (lbracket)))
				((-jump-) (" (lbrace)))
				(" (lparen)storage(space)))]
			[print-expression (@ $s expr-reference)]
			[write-str (stdout) (" (space))]
			(foreach (t (@ $s expr-arguments)) (begin
				[print-expression $t]
				[write-str (stdout) (" (space))]))
			[write-str (stdout) (" (bs))]
			[write-str (stdout) (switch = (@ $s expr-type)
				((-invoke-) (" (rbracket)))
				((-jump-) (" (rbrace)))
				(" (rbracket)))]))
		
		((-function-) (-continuation-) (begin
			[write-str (stdout) (" (lparen))]
			[write-str (stdout) (switch = (@ $s expr-type)
				((-function-) (" function))
				(" continuation))]
			[write-str (stdout) (" (space))]
			[print-expression (@ $s expr-reference)]
			[write-str (stdout) (" (space)(lparen)(space))]
			(foreach (t (@ $s expr-parameters)) (begin
				[print-expression $t]
				[write-str (stdout) (" (space))]))
			[write-str (stdout) (" (rparen)(space))]
			[print-expression (@ $s expr-expression)]
			[write-str (stdout) (" (rparen))]))
			
		((-if-) (begin
			[write-str (stdout) (" (lparen)if(space))]
			[print-expression (@ $s expr-condition)]
			[write-str (stdout) (" (space))]
			[print-expression (@ $s expr-consequent)]
			[write-str (stdout) (" (space))]
			[print-expression (@ $s expr-alternate)]
			[write-str (stdout) (" (rparen))]))
		
		((-reference-)
			(if (@ $s expr-name)
				[write-str (stdout) (@ $s expr-name)]
				(begin
					[write-str (stdout) (" (lparen)reference(space))]
					[write-uint (stdout) (@ $s expr-symbol)]
					[write-str (stdout) (" (rparen))])))
					
		((-literal-) (begin
			[write-str (stdout) (" (lparen)literal(space))]
			[write-uint (stdout) (@ $s expr-value)]
			[write-str (stdout) (" (rparen))]))
		
		((-non-primitive-) (begin
			[write-str (stdout) (" (lparen))]
			[print-expression (@ $s expr-reference)]
			[write-str (stdout) (" (space))]
			[print-fragment (@ $s expr-argument)]
			[write-str (stdout) (" (rparen))]))
			
		(begin)))

(function build-expression-literal-len (l r p) [mk# $l $r $p #64])

(storage special-form-error #0)

(function build-expression (d reg handler)
	(if [= [length $d] #0] {$handler}
	(if [i/f:symbol? $d] [make-reference [to-string $d $reg] $reg]
	(switch str= [to-string [@car $d] $reg]
		((" with)
			(if (not [= [length $d] #3])
				{$handler special-form-error $d (null)}
			(if (not [i/f:symbol? [@cadr $d]])
				{$handler special-form-error $d [@cadr $d]}
				[make-with [build-expression [@cadr $d] $reg $handler] [build-expression [@caddr $d] $reg $handler] $reg])))
		
		((" begin)
			(with return (let (exprs nil) (begin
				(foreach (v [@cdr $d]) [append [build-expression $v $reg $handler] exprs $reg])
				{return [make-begin $exprs $reg]}))))
		
		((" if)
			(if (not [= [length $d] #4])
				{$handler special-form-error $d (null)}
				[make-if [build-expression [@cadr $d] $reg $handler] [build-expression [@caddr $d] $reg $handler]
					[build-expression [@cadddr $d] $reg $handler] $reg]))
		
		((" function) (" continuation)
			(if (not [= [length $d] #4])
				{$handler special-form-error $d (null)}
			(if (not [i/f:symbol? [@cadr $d]])
				{$handler special-form-error $d [@cadr $d]}
			(if [i/f:symbol? [@caddr $d]]
				{$handler special-form-error $d [@caddr $d]}
				(with return (let (parameters nil) (begin
					(foreach (v [@caddr $d])
						(if [i/f:symbol? $v]
							[append [build-expression $v $reg $handler] parameters $reg]
							{$handler special-form-error $d $v}))
					{return [(switch str= [to-string [@car $d] $reg]
							((" function) make-function)
							make-continuation)
						[build-expression [@cadr $d] $reg $handler] $parameters [build-expression [@cadddr $d] $reg $handler]
							$reg]})))))))
		
		((" invoke) (" jump) (" storage)
			(if [= [length $d] #1]
				{$handler special-form-error $d (null)}
			(if (and [str= [to-string [@car $d] $reg] (" storage)] (not [i/f:symbol? [@cadr $d]]))
				{$handler special-form-error $d [@cadr $d]}
				(with return (let (arguments nil) (begin
					(foreach (v [@cddr $d]) [append [build-expression $v $reg $handler] arguments $reg])
					{return [(switch str= [to-string [@car $d] $reg]
							((" invoke) make-invoke)
							((" jump) make-jump)
							make-storage)
						[build-expression [@cadr $d] $reg $handler] $arguments $reg]}))))))
		
		((" literal)
			(if (not [= [length $d] #2])
				{$handler special-form-error $d (null)}
			(if (or (not [i/f:symbol? [@cadr $d]]) (not [= [length [@cadr $d]] (build-expression-literal-len)]))
				{$handler special-form-error $d [@cadr $d]}
				[make-literal (with return
					{(continuation loop (str i value) (begin
							[set value [<< $value #1]]
							(if [= $i #0]
								{return $value}
							(if [= [getb $str] (char 1)]
								{loop [+ $str #1] [- $i #1] [+ $value #1]}
							(if [= [getb $str] (char 0)]
								{loop [+ $str #1] [- $i #1] $value}
								{$handler special-form-error $d [@cadr $d]})))))
						[to-string [@cadr $d] $reg] (build-expression-literal-len) #0}) $reg])))
		
		[make-non-primitive [build-expression [@car $d] $reg $handler] [@cdr $d] $reg]))))

(let (r [create-region #0]) [print-expression [make-begin [llst [make-reference (" Hellodude) $r] [make-literal #20 $r] nil $r] $r]])

[write-str (stdout) (" Starting here:(lf))]

(++(let (r [create-region #0]) (pos #0)
	(do-let (begin
			[write-str (stdout) (" (lparen)begin(lbrace)lokay(rbrace)a(rparen)o)]
			[print-expression [build-expression
				[build-fragment (" (lparen)with(lbrace)lokay(rbrace)a(rparen)o) #22 pos $r $handler] $r $handler]]
			[build-symbol (" Hello) $r])
		(handler (continuation _ (code arg0 arg1 arg2 arg3) (begin
			[destroy-region $r]
			(switch = $code
				(special-form-error [write-str (stdout) (" Okay, it's a special form error(lf))])
				(unexpected-char-error [write-str (stdout) (" It was an unexpected character!(lf))])
				[write-str (stdout) (" We do not know what caused this!(lf))])
			[exit #1]))))))
